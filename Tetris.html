<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Trippy Tetris">
    <meta property="og:description" content="Experience Tetris like never before with psychedelic visuals and mind-bending effects">
    <meta property="og:image" content="https://cdn.simulationtheory.ai/gasset/?asset=img&prompt=tetris blocks with psychedelic patterns and colors&w=1200&h=630&style=realistic">
    <meta property="og:type" content="website">
    <title>Trippy Tetris</title>
    <link rel="icon" href="https://cdn.simulationtheory.ai/gasset/?asset=img&prompt=tetris block psychedelic icon&w=32&h=32&transparent=true">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @font-face {
            font-family: 'Retro Gaming';
            src: url('https://fonts.gstatic.com/s/pressstart2p/v14/e3t4euO8T-267oIAQAu6jDQyK3nVivNm4I81.woff2') format('woff2');
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Retro Gaming', sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas {
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.7);
        }

        #background-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .game-ui {
            position: absolute;
            padding: 15px;
            border-radius: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
            color: #fff;
            font-size: 18px;
            text-shadow: 0 0 5px #ff00ff;
        }

        #score-container {
            top: 20px;
            right: 20px;
        }

        #next-piece {
            top: 20px;
            left: 20px;
        }

        #level-container {
            bottom: 20px;
            right: 20px;
        }

        #controls {
            bottom: 20px;
            left: 20px;
        }

        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
        }

        .btn {
            padding: 15px 30px;
            margin: 10px;
            border: none;
            border-radius: 5px;
            font-size: 20px;
            font-family: 'Retro Gaming', sans-serif;
            cursor: pointer;
            background: linear-gradient(45deg, #ff00ff, #00ffff);
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }

        .btn:before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, rgba(255, 0, 255, 0.3), rgba(0, 255, 255, 0.3), rgba(255, 255, 0, 0.3));
            transform: rotate(45deg);
            animation: shimmer 3s infinite linear;
            z-index: -1;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }

        .volume-control {
            display: flex;
            align-items: center;
            margin-top: 20px;
        }

        .volume-slider {
            width: 100px;
            margin: 0 10px;
        }

        .hidden {
            display: none;
        }

        .game-over-text {
            font-size: 48px;
            color: #ff00ff;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 30px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); text-shadow: 0 0 10px #00ffff; }
            50% { transform: scale(1.05); text-shadow: 0 0 20px #ff00ff; }
            100% { transform: scale(1); text-shadow: 0 0 10px #00ffff; }
        }

        .high-score {
            font-size: 24px;
            color: #ffff00;
            margin-bottom: 20px;
            text-shadow: 0 0 8px #ff00ff;
        }

        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 5;
        }

        .touch-btn {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            text-shadow: 0 0 5px #ff00ff;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        @media (min-width: 768px) {
            #touch-controls {
                display: none;
            }
        }

        .tutorial {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            max-width: 80%;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }

        .tutorial p {
            margin: 5px 0;
        }

        .tutorial-close {
            position: absolute;
            top: 5px;
            right: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Home Button -->
        <a href="index.html" class="lsd-home-button">
          <svg viewBox="0 0 64 64" class="home-icon" xmlns="http://www.w3.org/2000/svg">
            <path d="M32 12l22 22h-6v18h-12v-12h-8v12h-12v-18h-6z"/>
          </svg>
        </a>
        
        <canvas id="background-canvas"></canvas>
        <canvas id="game-canvas"></canvas>
        
        <div id="score-container" class="game-ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lines: <span id="lines">0</span></div>
        </div>
        
        <div id="next-piece" class="game-ui">
            <div>Next:</div>
            <canvas id="next-canvas" width="100" height="100"></canvas>
        </div>
        
        <div id="level-container" class="game-ui">
            <div>Level: <span id="level">1</span></div>
        </div>
        
        <div id="controls" class="game-ui">
            <div>← → : Move</div>
            <div>↑ : Rotate</div>
            <div>↓ : Soft Drop</div>
            <div>Space : Hard Drop</div>
            <div>P : Pause</div>
        </div>

        <div id="touch-controls">
            <div class="touch-btn" id="touch-left">←</div>
            <div class="touch-btn" id="touch-rotate">↑</div>
            <div class="touch-btn" id="touch-right">→</div>
            <div class="touch-btn" id="touch-down">↓</div>
            <div class="touch-btn" id="touch-drop">⬇⬇</div>
        </div>

        <div id="start-menu" class="menu">
            <h1 class="text-5xl mb-8 text-center" style="color: #ff00ff; text-shadow: 0 0 10px #00ffff;">TRIPPY TETRIS</h1>
            <button id="start-button" class="btn">START GAME</button>
            <div class="volume-control">
                <span>Music:</span>
                <input type="range" min="0" max="1" step="0.1" value="0.5" class="volume-slider" id="music-volume">
                <span>SFX:</span>
                <input type="range" min="0" max="1" step="0.1" value="0.7" class="volume-slider" id="sfx-volume">
            </div>
        </div>

        <div id="pause-menu" class="menu hidden">
            <h2 class="text-4xl mb-8" style="color: #00ffff; text-shadow: 0 0 10px #ff00ff;">GAME PAUSED</h2>
            <button id="resume-button" class="btn">RESUME</button>
            <button id="restart-button" class="btn">RESTART</button>
            <div class="volume-control">
                <span>Music:</span>
                <input type="range" min="0" max="1" step="0.1" value="0.5" class="volume-slider" id="music-volume-pause">
                <span>SFX:</span>
                <input type="range" min="0" max="1" step="0.1" value="0.7" class="volume-slider" id="sfx-volume-pause">
            </div>
        </div>

        <div id="game-over-menu" class="menu hidden">
            <div class="game-over-text">GAME OVER</div>
            <div class="high-score">High Score: <span id="high-score">0</span></div>
            <button id="play-again-button" class="btn">PLAY AGAIN</button>
        </div>

        <div id="tutorial" class="tutorial">
            <span class="tutorial-close">✕</span>
            <h3>How to Play</h3>
            <p>Stack the falling blocks to create complete lines</p>
            <p>Complete lines will disappear and earn points</p>
            <p>The game ends when blocks reach the top</p>
            <p>Watch out for the trippy effects!</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = 30;
            const COLORS = [
                '#FF00FF', // Magenta
                '#00FFFF', // Cyan
                '#FFFF00', // Yellow
                '#FF0000', // Red
                '#00FF00', // Green
                '#0000FF', // Blue
                '#FF8800'  // Orange
            ];

            // Game variables
            let canvas, ctx;
            let nextCanvas, nextCtx;
            let backgroundCanvas, backgroundCtx;
            let board = [];
            let currentPiece, nextPiece;
            let score = 0;
            let lines = 0;
            let level = 1;
            let gameInterval;
            let gameSpeed = 1000; // Initial speed in milliseconds
            let gameState = 'menu'; // menu, playing, paused, gameOver
            let highScore = localStorage.getItem('trippyTetrisHighScore') || 0;
            let lastTime = 0;
            let dropCounter = 0;
            let particleSystems = [];
            let hueShift = 0;
            let waveIntensity = 0;
            let pulseSize = 1;
            let trailEffects = [];
            let backgroundParticles = [];
            let tutorialShown = localStorage.getItem('tutorialShown') || false;
            let sparkEffects = [];
            let impactWaves = [];
            let screenPulse = 1;
        
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let musicVolume = 0.5;
            let sfxVolume = 0.7;
            let backgroundMusic;
            let soundEffects = {};

            // Tetromino shapes
            const SHAPES = [
                [[1, 1, 1, 1]],                         // I
                [[1, 1], [1, 1]],                       // O
                [[0, 1, 0], [1, 1, 1]],                 // T
                [[0, 1, 1], [1, 1, 0]],                 // S
                [[1, 1, 0], [0, 1, 1]],                 // Z
                [[1, 0, 0], [1, 1, 1]],                 // L
                [[0, 0, 1], [1, 1, 1]]                  // J
            ];

            // Initialize the game
            function init() {
                // Set up canvases
                canvas = document.getElementById('game-canvas');
                ctx = canvas.getContext('2d');
                
                nextCanvas = document.getElementById('next-canvas');
                nextCtx = nextCanvas.getContext('2d');
                
                backgroundCanvas = document.getElementById('background-canvas');
                backgroundCtx = backgroundCanvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = COLS * BLOCK_SIZE;
                canvas.height = ROWS * BLOCK_SIZE;
                
                // Resize background canvas to fill window
                resizeBackgroundCanvas();
                window.addEventListener('resize', resizeBackgroundCanvas);
                
                // Initialize the board
                createBoard();
                
                // Set up event listeners
                document.addEventListener('keydown', handleKeyPress);
                
                // Set up touch controls
                setupTouchControls();
                
                // Set up menu buttons
                document.getElementById('start-button').addEventListener('click', startGame);
                document.getElementById('resume-button').addEventListener('click', resumeGame);
                document.getElementById('restart-button').addEventListener('click', restartGame);
                document.getElementById('play-again-button').addEventListener('click', restartGame);
                
                // Set up volume controls
                setupVolumeControls();
                
                // Tutorial close button
                document.querySelector('.tutorial-close').addEventListener('click', () => {
                    document.getElementById('tutorial').classList.add('hidden');
                    localStorage.setItem('tutorialShown', 'true');
                });
                
                // Update high score display
                document.getElementById('high-score').textContent = highScore;
                
                // Start the animation loop
                requestAnimationFrame(gameLoop);
                
                // Initialize background effects
                createBackgroundParticles();
            }

            function resizeBackgroundCanvas() {
                backgroundCanvas.width = window.innerWidth;
                backgroundCanvas.height = window.innerHeight;
            }

            function createBoard() {
                board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            }

            function setupTouchControls() {
                document.getElementById('touch-left').addEventListener('touchstart', () => movePiece(-1, 0));
                document.getElementById('touch-right').addEventListener('touchstart', () => movePiece(1, 0));
                document.getElementById('touch-rotate').addEventListener('touchstart', rotatePiece);
                document.getElementById('touch-down').addEventListener('touchstart', () => movePiece(0, 1));
                document.getElementById('touch-drop').addEventListener('touchstart', hardDrop);
            }

            function setupVolumeControls() {
                const musicSliders = document.querySelectorAll('#music-volume, #music-volume-pause');
                const sfxSliders = document.querySelectorAll('#sfx-volume, #sfx-volume-pause');
                
                musicSliders.forEach(slider => {
                    slider.value = musicVolume;
                    slider.addEventListener('input', (e) => {
                        musicVolume = parseFloat(e.target.value);
                        musicSliders.forEach(s => s.value = musicVolume);
                        if (backgroundMusic) {
                            backgroundMusic.volume = musicVolume;
                        }
                    });
                });
                
                sfxSliders.forEach(slider => {
                    slider.value = sfxVolume;
                    slider.addEventListener('input', (e) => {
                        sfxVolume = parseFloat(e.target.value);
                        sfxSliders.forEach(s => s.value = sfxVolume);
                    });
                });
            }

            // Game state management
            function startGame() {
                if (gameState === 'menu') {
                    gameState = 'playing';
                    document.getElementById('start-menu').classList.add('hidden');
                    
                    // Show tutorial if not shown before
                    if (!tutorialShown) {
                        document.getElementById('tutorial').classList.remove('hidden');
                    } else {
                        document.getElementById('tutorial').classList.add('hidden');
                    }
                    
                    resetGame();
                    loadAudio();
                }
            }

            function pauseGame() {
                if (gameState === 'playing') {
                    gameState = 'paused';
                    document.getElementById('pause-menu').classList.remove('hidden');
                    if (backgroundMusic) {
                        backgroundMusic.pause();
                    }
                }
            }

            function resumeGame() {
                if (gameState === 'paused') {
                    gameState = 'playing';
                    document.getElementById('pause-menu').classList.add('hidden');
                    if (backgroundMusic) {
                        backgroundMusic.play();
                    }
                }
            }

            function gameOver() {
                gameState = 'gameOver';
                document.getElementById('game-over-menu').classList.remove('hidden');
                
                // Update high score
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('trippyTetrisHighScore', highScore);
                    document.getElementById('high-score').textContent = highScore;
                }
                
                // Play game over sound
                playSound('gameOver');
                
                // Stop background music
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
                
                // Add explosion particles
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            createParticleSystem(
                                x * BLOCK_SIZE + BLOCK_SIZE / 2,
                                y * BLOCK_SIZE + BLOCK_SIZE / 2,
                                COLORS[board[y][x] - 1],
                                50
                            );
                        }
                    }
                }
            }

            function restartGame() {
                document.getElementById('game-over-menu').classList.add('hidden');
                document.getElementById('pause-menu').classList.add('hidden');
                resetGame();
                gameState = 'playing';
                
                // Restart music
                if (backgroundMusic) {
                    backgroundMusic.currentTime = 0;
                    backgroundMusic.play();
                }
            }

            function resetGame() {
                createBoard();
                score = 0;
                lines = 0;
                level = 1;
                gameSpeed = 1000;
                waveIntensity = 0;
                
                // Update UI
                document.getElementById('score').textContent = score;
                document.getElementById('lines').textContent = lines;
                document.getElementById('level').textContent = level;
                
                // Create new pieces
                createNewPiece();
                createNewPiece();
                
                // Clear effects
                particleSystems = [];
                trailEffects = [];
            }

            // Piece management
            function createNewPiece() {
                if (currentPiece === undefined) {
                    currentPiece = {
                        shape: getRandomShape(),
                        color: Math.floor(Math.random() * COLORS.length),
                        x: Math.floor(COLS / 2) - 1,
                        y: 0
                    };
                } else {
                    currentPiece = nextPiece;
                }
                
                nextPiece = {
                    shape: getRandomShape(),
                    color: Math.floor(Math.random() * COLORS.length),
                    x: Math.floor(COLS / 2) - 1,
                    y: 0
                };
                
                // Draw next piece
                drawNextPiece();
                
                // Check if game over
                if (checkCollision(currentPiece)) {
                    gameOver();
                }
            }

            function getRandomShape() {
                return JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random() * SHAPES.length)]));
            }

            function drawNextPiece() {
                nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
                
                const shape = nextPiece.shape;
                const blockSize = 20;
                const offsetX = (nextCanvas.width - shape[0].length * blockSize) / 2;
                const offsetY = (nextCanvas.height - shape.length * blockSize) / 2;
                
                shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const colorIndex = (nextPiece.color + Math.floor(hueShift / 30)) % COLORS.length;
                            drawTripBlock(
                                nextCtx,
                                offsetX + x * blockSize,
                                offsetY + y * blockSize,
                                blockSize,
                                COLORS[colorIndex],
                                0.5
                            );
                        }
                    });
                });
            }

            // Game mechanics
            function movePiece(dx, dy) {
                if (gameState !== 'playing') return;
                
                currentPiece.x += dx;
                currentPiece.y += dy;
                
                if (checkCollision(currentPiece)) {
                    currentPiece.x -= dx;
                    currentPiece.y -= dy;
                    
                    // If collision on downward movement, lock the piece
                    if (dy > 0) {
                        lockPiece();
                        clearLines();
                        createNewPiece();
                    }
                    return false;
                }
                
                // Add trail effect
                if (dy > 0) {
                    addTrailEffect();
                }
                
                playSound('move');
                return true;
            }

            function rotatePiece() {
                if (gameState !== 'playing') return;
                
                const originalShape = JSON.parse(JSON.stringify(currentPiece.shape));
                const rows = currentPiece.shape.length;
                const cols = currentPiece.shape[0].length;
                
                // Create a new rotated shape
                const rotatedShape = Array.from({ length: cols }, () => Array(rows).fill(0));
                
                for (let y = 0; y < rows; y++) {
                    for (let x = 0; x < cols; x++) {
                        rotatedShape[x][rows - 1 - y] = currentPiece.shape[y][x];
                    }
                }
                
                currentPiece.shape = rotatedShape;
                
                // If collision after rotation, revert back
                if (checkCollision(currentPiece)) {
                    currentPiece.shape = originalShape;
                    return false;
                }
                
                playSound('rotate');
                
                // Add particle effect for rotation
                const centerX = (currentPiece.x + currentPiece.shape[0].length / 2) * BLOCK_SIZE;
                const centerY = (currentPiece.y + currentPiece.shape.length / 2) * BLOCK_SIZE;
                createParticleSystem(centerX, centerY, COLORS[currentPiece.color], 20);
                
                return true;
            }

            function hardDrop() {
                if (gameState !== 'playing') return;
                
                let dropDistance = 0;
                while (movePiece(0, 1)) {
                    dropDistance++;
                }
                
                // Add score for hard drop
                updateScore(dropDistance);
                
                // Play sound
                playSound('hardDrop');
            }

            function checkCollision(piece) {
                const shape = piece.shape;
                const pieceX = piece.x;
                const pieceY = piece.y;
                
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const boardX = pieceX + x;
                            const boardY = pieceY + y;
                            
                            // Check boundaries
                            if (
                                boardX < 0 ||
                                boardX >= COLS ||
                                boardY >= ROWS ||
                                (boardY >= 0 && board[boardY][boardX])
                            ) {
                                return true; // Collision detected
                            }
                        }
                    }
                }
                
                return false; // No collision
            }

            function lockPiece() {
                const shape = currentPiece.shape;
                const pieceX = currentPiece.x;
                const pieceY = currentPiece.y;
                const colorIndex = currentPiece.color + 1; // +1 because 0 means empty
                
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const boardY = pieceY + y;
                            const boardX = pieceX + x;
                            
                            if (boardY >= 0) {
                                board[boardY][boardX] = colorIndex;
                                
                                // Add spark effect at each block position
                                createSparkEffect(
                                    boardX * BLOCK_SIZE + BLOCK_SIZE / 2,
                                    boardY * BLOCK_SIZE + BLOCK_SIZE / 2,
                                    COLORS[colorIndex - 1]
                                );
                            }
                        }
                    }
                }
                
                // Play enhanced lock sound with a slight pitch variation
                const lockSound = soundEffects['lock'].cloneNode(true);
                lockSound.volume = sfxVolume * 0.8;
                lockSound.playbackRate = 0.8 + Math.random() * 0.4; // Random pitch between 0.8 and 1.2
                lockSound.play().catch(e => console.log('Audio playback failed:', e));
                
                // Add screen pulse effect
                addScreenPulse();
                
                // Add impact particles
                const centerX = (pieceX + shape[0].length / 2) * BLOCK_SIZE;
                const centerY = (pieceY + shape.length / 2) * BLOCK_SIZE;
                createImpactWave(centerX, centerY, COLORS[currentPiece.color]);
            }

            function createSparkEffect(x, y, color) {
                const sparkCount = 8 + Math.floor(Math.random() * 8);
                
                for (let i = 0; i < sparkCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    const life = 15 + Math.random() * 15;
                    
                    const spark = {
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: 1 + Math.random() * 2,
                        color: color,
                        life: life,
                        maxLife: life,
                        decay: 0.9 + Math.random() * 0.1
                    };
                    
                    sparkEffects.push(spark);
                }
            }

            function createImpactWave(x, y, color) {
                impactWaves.push({
                    x: x,
                    y: y,
                    radius: 5,
                    maxRadius: BLOCK_SIZE * 3,
                    color: color,
                    alpha: 0.7,
                    lineWidth: 3
                });
            }

            function addScreenPulse() {
                screenPulse = 1.2; // Start with 20% zoom
            }

            function clearLines() {
                let linesCleared = 0;
                let linesToClear = [];
                
                // Find complete lines
                for (let y = ROWS - 1; y >= 0; y--) {
                    let lineComplete = true;
                    
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x] === 0) {
                            lineComplete = false;
                            break;
                        }
                    }
                    
                    if (lineComplete) {
                        linesToClear.push(y);
                        linesCleared++;
                    }
                }
                
                // Create particle effects for cleared lines
                linesToClear.forEach(y => {
                    for (let x = 0; x < COLS; x++) {
                        const colorIndex = board[y][x] - 1;
                        createParticleSystem(
                            x * BLOCK_SIZE + BLOCK_SIZE / 2,
                            y * BLOCK_SIZE + BLOCK_SIZE / 2,
                            COLORS[colorIndex],
                            30
                        );
                    }
                });
                
                // Remove lines and shift down
                linesToClear.forEach(lineY => {
                    for (let y = lineY; y > 0; y--) {
                        for (let x = 0; x < COLS; x++) {
                            board[y][x] = board[y - 1][x];
                        }
                    }
                    
                    // Clear the top line
                    for (let x = 0; x < COLS; x++) {
                        board[0][x] = 0;
                    }
                });
                
                // Update score and level
                if (linesCleared > 0) {
                    updateScore(linesCleared * 100 * linesCleared); // More points for multiple lines
                    lines += linesCleared;
                    document.getElementById('lines').textContent = lines;
                    
                    // Increase level every 10 lines
                    const newLevel = Math.floor(lines / 10) + 1;
                    if (newLevel > level) {
                        level = newLevel;
                        gameSpeed = Math.max(100, 1000 - (level - 1) * 100); // Speed up as level increases
                        document.getElementById('level').textContent = level;
                        
                        // Increase wave intensity with level
                        waveIntensity = Math.min(10, level);
                        
                        playSound('levelUp');
                    }
                    
                    // Play appropriate sound
                    if (linesCleared === 4) {
                        playSound('tetris');
                    } else {
                        playSound('lineClear');
                    }
                    
                    // Add screen shake effect
                    addScreenShake(linesCleared * 5);
                }
            }

            function updateScore(points) {
                score += points * level;
                document.getElementById('score').textContent = score;
            }

            // Rendering
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw board
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (board[y][x]) {
                            const colorIndex = (board[y][x] - 1 + Math.floor(hueShift / 30)) % COLORS.length;
                            drawTripBlock(
                                ctx,
                                x * BLOCK_SIZE,
                                y * BLOCK_SIZE,
                                BLOCK_SIZE,
                                COLORS[colorIndex],
                                waveIntensity / 10
                            );
                        }
                    }
                }
                
                // Draw current piece
                if (currentPiece && gameState === 'playing') {
                    const shape = currentPiece.shape;
                    const pieceX = currentPiece.x;
                    const pieceY = currentPiece.y;
                    const colorIndex = (currentPiece.color + Math.floor(hueShift / 30)) % COLORS.length;
                    
                    // Draw ghost piece (preview of where piece will land)
                    let ghostY = pieceY;
                    while (!checkCollision({
                        shape,
                        x: pieceX,
                        y: ghostY + 1
                    })) {
                        ghostY++;
                    }
                    
                    // Draw ghost piece with transparency
                    shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                ctx.globalAlpha = 0.3;
                                drawTripBlock(
                                    ctx,
                                    (pieceX + x) * BLOCK_SIZE,
                                    (ghostY + y) * BLOCK_SIZE,
                                    BLOCK_SIZE,
                                    COLORS[colorIndex],
                                    waveIntensity / 10
                                );
                                ctx.globalAlpha = 1;
                            }
                        });
                    });
                    
                    // Draw actual piece
                    shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                drawTripBlock(
                                    ctx,
                                    (pieceX + x) * BLOCK_SIZE,
                                    (pieceY + y) * BLOCK_SIZE,
                                    BLOCK_SIZE,
                                    COLORS[colorIndex],
                                    waveIntensity / 10
                                );
                            }
                        });
                    });
                }
            }

            function drawTripBlock(context, x, y, size, baseColor, intensity) {
                const time = Date.now() / 1000;
                const pulseEffect = 1 + Math.sin(time * 2) * 0.1 * intensity;
                const adjustedSize = size * pulseEffect * pulseSize;
                
                // Calculate center and offset to keep block centered despite size changes
                const centerX = x + size / 2;
                const centerY = y + size / 2;
                const offsetX = centerX - adjustedSize / 2;
                const offsetY = centerY - adjustedSize / 2;
                
                // Create gradient
                const gradient = context.createLinearGradient(
                    offsetX,
                    offsetY,
                    offsetX + adjustedSize,
                    offsetY + adjustedSize
                );
                
                // Get base color components
                const r = parseInt(baseColor.slice(1, 3), 16);
                const g = parseInt(baseColor.slice(3, 5), 16);
                const b = parseInt(baseColor.slice(5, 7), 16);
                
                // Create trippy color variations
                const color1 = `rgb(${r}, ${g}, ${b})`;
                const color2 = `rgb(${b}, ${r}, ${g})`;
                const color3 = `rgb(${g}, ${b}, ${r})`;
                
                gradient.addColorStop(0, color1);
                gradient.addColorStop(0.5, color2);
                gradient.addColorStop(1, color3);
                
                context.fillStyle = gradient;
                
                // Apply wavy effect to block shape
                if (intensity > 0) {
                    context.beginPath();
                    
                    // Top edge with wave
                    const waveAmplitude = 3 * intensity;
                    const waveFrequency = 2;
                    
                    context.moveTo(
                        offsetX,
                        offsetY + Math.sin(time * 3 + x / 30) * waveAmplitude
                    );
                    
                    // Top edge
                    for (let i = 0; i <= adjustedSize; i += 5) {
                        context.lineTo(
                            offsetX + i,
                            offsetY + Math.sin(time * 3 + (x + i) / 30) * waveAmplitude
                        );
                    }
                    
                    // Right edge
                    for (let i = 0; i <= adjustedSize; i += 5) {
                        context.lineTo(
                            offsetX + adjustedSize,
                            offsetY + i + Math.sin(time * 2.5 + (y + i) / 30) * waveAmplitude
                        );
                    }
                    
                    // Bottom edge
                    for (let i = adjustedSize; i >= 0; i -= 5) {
                        context.lineTo(
                            offsetX + i,
                            offsetY + adjustedSize + Math.sin(time * 3.2 + (x + i) / 30) * waveAmplitude
                        );
                    }
                    
                    // Left edge
                    for (let i = adjustedSize; i >= 0; i -= 5) {
                        context.lineTo(
                            offsetX,
                            offsetY + i + Math.sin(time * 2.7 + (y + i) / 30) * waveAmplitude
                        );
                    }
                    
                    context.closePath();
                    context.fill();
                    
                    // Add glow effect
                    context.shadowColor = baseColor;
                    context.shadowBlur = 10 * intensity;
                    context.fill();
                    context.shadowBlur = 0;
                } else {
                    // Simple block without effects
                    context.fillRect(offsetX, offsetY, adjustedSize, adjustedSize);
                }
                
                // Add inner detail
                context.fillStyle = `rgba(255, 255, 255, 0.3)`;
                context.fillRect(
                    offsetX + adjustedSize * 0.25,
                    offsetY + adjustedSize * 0.25,
                    adjustedSize * 0.2,
                    adjustedSize * 0.2
                );
            }

            // Special effects
            function createParticleSystem(x, y, color, count) {
                const particles = [];
                
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 3;
                    
                    particles.push({
                        x,
                        y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        radius: 1 + Math.random() * 3,
                        color,
                        life: 30 + Math.random() * 30
                    });
                }
                
                particleSystems.push(particles);
            }

            function updateParticles() {
                for (let i = particleSystems.length - 1; i >= 0; i--) {
                    const particles = particleSystems[i];
                    
                    for (let j = particles.length - 1; j >= 0; j--) {
                        const p = particles[j];
                        
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life--;
                        
                        if (p.life <= 0) {
                            particles.splice(j, 1);
                        }
                    }
                    
                    if (particles.length === 0) {
                        particleSystems.splice(i, 1);
                    }
                }
            }

            function drawParticles() {
                particleSystems.forEach(particles => {
                    particles.forEach(p => {
                        ctx.globalAlpha = p.life / 60;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                });
                ctx.globalAlpha = 1;
            }

            function addTrailEffect() {
                if (currentPiece) {
                    const shape = currentPiece.shape;
                    const pieceX = currentPiece.x;
                    const pieceY = currentPiece.y;
                    const colorIndex = currentPiece.color;
                    
                    shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                trailEffects.push({
                                    x: (pieceX + x) * BLOCK_SIZE,
                                    y: (pieceY + y) * BLOCK_SIZE,
                                    size: BLOCK_SIZE,
                                    color: COLORS[colorIndex],
                                    life: 10
                                });
                            }
                        });
                    });
                }
            }

            function updateTrailEffects() {
                for (let i = trailEffects.length - 1; i >= 0; i--) {
                    const trail = trailEffects[i];
                    trail.life--;
                    
                    if (trail.life <= 0) {
                        trailEffects.splice(i, 1);
                    }
                }
            }

            function drawTrailEffects() {
                trailEffects.forEach(trail => {
                    ctx.globalAlpha = trail.life / 10 * 0.3;
                    ctx.fillStyle = trail.color;
                    ctx.fillRect(trail.x, trail.y, trail.size, trail.size);
                });
                ctx.globalAlpha = 1;
            }

            let shakeAmount = 0;
            let shakeX = 0;
            let shakeY = 0;

            function addScreenShake(amount) {
                shakeAmount = amount;
            }

            function updateScreenShake() {
                if (shakeAmount > 0) {
                    shakeX = (Math.random() - 0.5) * shakeAmount;
                    shakeY = (Math.random() - 0.5) * shakeAmount;
                    shakeAmount *= 0.9;
                    
                    if (shakeAmount < 0.5) {
                        shakeAmount = 0;
                        shakeX = 0;
                        shakeY = 0;
                    }
                }
            }

            function applyScreenShake() {
                if (shakeAmount > 0) {
                    canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                } else {
                    canvas.style.transform = 'translate(0, 0)';
                }
            }

            // Background effects
            function createBackgroundParticles() {
                const count = 100;
                
                for (let i = 0; i < count; i++) {
                    backgroundParticles.push({
                        x: Math.random() * backgroundCanvas.width,
                        y: Math.random() * backgroundCanvas.height,
                        size: 1 + Math.random() * 3,
                        speed: 0.2 + Math.random() * 0.5,
                        angle: Math.random() * Math.PI * 2,
                        hue: Math.random() * 360
                    });
                }
            }

            function updateBackgroundParticles() {
                backgroundParticles.forEach(p => {
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                    p.angle += (Math.random() - 0.5) * 0.1;
                    
                    // Wrap around edges
                    if (p.x < 0) p.x = backgroundCanvas.width;
                    if (p.x > backgroundCanvas.width) p.x = 0;
                    if (p.y < 0) p.y = backgroundCanvas.height;
                    if (p.y > backgroundCanvas.height) p.y = 0;
                });
            }

            function drawBackground() {
                // Create gradient background
                const gradient = backgroundCtx.createRadialGradient(
                    backgroundCanvas.width / 2,
                    backgroundCanvas.height / 2,
                    0,
                    backgroundCanvas.width / 2,
                    backgroundCanvas.height / 2,
                    backgroundCanvas.width
                );
                
                const time = Date.now() / 10000;
                const hue1 = (time * 20) % 360;
                const hue2 = (hue1 + 180) % 360;
                
                gradient.addColorStop(0, `hsl(${hue1}, 70%, 10%)`);
                gradient.addColorStop(1, `hsl(${hue2}, 70%, 5%)`);
                
                backgroundCtx.fillStyle = gradient;
                backgroundCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
                
                // Draw particles
                backgroundParticles.forEach(p => {
                    backgroundCtx.fillStyle = `hsla(${(p.hue + hueShift) % 360}, 100%, 70%, 0.7)`;
                    backgroundCtx.beginPath();
                    backgroundCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    backgroundCtx.fill();
                });
                
                // Draw flowing patterns
                const patternCount = 3;
                for (let i = 0; i < patternCount; i++) {
                    const t = time * 2 + i * Math.PI / patternCount;
                    const points = 100;
                    const radius = Math.min(backgroundCanvas.width, backgroundCanvas.height) * 0.4;
                    
                    backgroundCtx.beginPath();
                    
                    for (let j = 0; j <= points; j++) {
                        const angle = (j / points) * Math.PI * 2;
                        const x = backgroundCanvas.width / 2 + Math.cos(angle) * radius * (1 + 0.2 * Math.sin(t + angle * 3));
                        const y = backgroundCanvas.height / 2 + Math.sin(angle) * radius * (1 + 0.2 * Math.sin(t + angle * 2));
                        
                        if (j === 0) {
                            backgroundCtx.moveTo(x, y);
                        } else {
                            backgroundCtx.lineTo(x, y);
                        }
                    }
                    
                    backgroundCtx.closePath();
                    backgroundCtx.strokeStyle = `hsla(${(hue1 + i * 120) % 360}, 100%, 70%, 0.2)`;
                    backgroundCtx.lineWidth = 2;
                    backgroundCtx.stroke();
                }
            }

            // Audio
            function loadAudio() {
                // Load background music
                backgroundMusic = new Audio('https://cdn.simulationtheory.ai/gasset/?asset=song&prompt=trippy electronic music with psychedelic vibes&style=instrumental&tags=electronic');
                backgroundMusic.loop = true;
                backgroundMusic.volume = musicVolume;
                
                // Load sound effects
                soundEffects = {
                    move: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=soft click sound'),
                    rotate: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=whoosh sound effect'),
                    lock: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=block landing sound'),
                    lineClear: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=line clear sound with sparkle'),
                    tetris: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=tetris line clear achievement sound'),
                    levelUp: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=level up sound with ascending tone'),
                    gameOver: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=game over sound with descending tone'),
                    hardDrop: new Audio('https://cdn.simulationtheory.ai/gasset/?asset=sound&prompt=quick drop sound effect')
                };
                
                // Start playing background music
                backgroundMusic.play().catch(e => {
                    console.log('Audio playback requires user interaction first');
                });
            }

            function playSound(soundName) {
                if (soundEffects[soundName]) {
                    const sound = soundEffects[soundName];
                    sound.volume = sfxVolume;
                    sound.currentTime = 0;
                    sound.play().catch(e => {
                        console.log('Audio playback failed:', e);
                    });
                }
            }

            // Input handling
            function handleKeyPress(e) {
                if (gameState !== 'playing') {
                    if (e.key === 'p' && gameState === 'paused') {
                        resumeGame();
                    }
                    return;
                }
                
                switch (e.key) {
                    case 'ArrowLeft':
                        movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePiece(1, 0);
                        break;
                    case 'ArrowDown':
                        movePiece(0, 1);
                        break;
                    case 'ArrowUp':
                        rotatePiece();
                        break;
                    case ' ':
                        hardDrop();
                        break;
                    case 'p':
                        pauseGame();
                        break;
                }
            }

            // Game loop
            function gameLoop(timestamp) {
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                
                // Update trippy effects
                hueShift = (hueShift + 0.5) % 360;
                pulseSize = 1 + Math.sin(timestamp / 1000) * 0.05;
                
                // Update background
                drawBackground();
                updateBackgroundParticles();
                
                // Update game state
                if (gameState === 'playing') {
                    dropCounter += deltaTime;
                    
                    if (dropCounter > gameSpeed) {
                        movePiece(0, 1);
                        dropCounter = 0;
                    }
                    
                    // Update effects
                    updateParticles();
                    updateTrailEffects();
                    updateScreenShake();
                }
                
                // Draw game
                draw();
                drawParticles();
                drawTrailEffects();
                applyScreenShake();
                
                // Continue animation loop
                requestAnimationFrame(gameLoop);
            }

            // Initialize the game
            init();
        });
    </script>
</body>
</html>
