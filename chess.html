import React, { useState, useEffect, useRef } from 'react';
import _ from 'lodash';

// Chess piece Unicode characters
const PIECES = {
  'wk': '♔', 'wq': '♕', 'wr': '♖', 'wb': '♗', 'wn': '♘', 'wp': '♙',
  'bk': '♚', 'bq': '♛', 'br': '♜', 'bb': '♝', 'bn': '♞', 'bp': '♟'
};

// Initial board setup
const initialBoard = [
  ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
  ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
  ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
];

const TripChess = () => {
  const [board, setBoard] = useState(initialBoard);
  const [selectedPiece, setSelectedPiece] = useState(null);
  const [possibleMoves, setPossibleMoves] = useState([]);
  const [turn, setTurn] = useState('w'); // 'w' for white, 'b' for black
  const [gameState, setGameState] = useState('playing'); // 'playing', 'check', 'checkmate'
  const [difficulty, setDifficulty] = useState('MEDIUM');
  const [tripLevel, setTripLevel] = useState(60); // Reduced default for better performance
  const [capturedPieces, setCapturedPieces] = useState({ w: [], b: [] });
  const [moveHistory, setMoveHistory] = useState([]);
  const [hueRotation, setHueRotation] = useState(0);
  const [saturation, setSaturation] = useState(100);
  const [pulseEffect, setPulseEffect] = useState(0);
  const [lastMove, setLastMove] = useState(null);
  const [autoPlay, setAutoPlay] = useState(false);
  const [aiThinking, setAiThinking] = useState(false);
  const [moveDelay, setMoveDelay] = useState(1000);
  
  const boardRef = useRef(null);
  const backgroundCanvasRef = useRef(null);
  
  // Color cycle effect
  useEffect(() => {
    const interval = setInterval(() => {
      setHueRotation(prev => (prev + 2) % 360);
      setSaturation(prev => 80 + Math.sin(Date.now() * 0.001) * 20);
    }, 50);
    
    return () => clearInterval(interval);
  }, []);
  
  // Pulse effect
  useEffect(() => {
    if (pulseEffect > 0) {
      const timer = setTimeout(() => 
        setPulseEffect(prev => Math.max(0, prev - 0.05)), 30);
      return () => clearTimeout(timer);
    }
  }, [pulseEffect]);

  // Background animation effect
  useEffect(() => {
    const canvas = backgroundCanvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationFrameId;
    let time = 0;
    
    // Set canvas dimensions
    const updateCanvasSize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };
    
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);
    
    const drawBackground = () => {
      time += 0.01;
      const intensity = tripLevel / 100;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw trippy background with flowing patterns
      for (let i = 0; i < 8; i++) {
        const radius = 150 + Math.sin(time * (i + 1) * 0.3) * 100 * intensity;
        const x = canvas.width / 2 + Math.cos(time * 0.5 * (i + 1)) * 200 * intensity;
        const y = canvas.height / 2 + Math.sin(time * 0.3 * (i + 1)) * 200 * intensity;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        const hue1 = (time * 30 + i * 30) % 360;
        const hue2 = (hue1 + 60) % 360;
        const hue3 = (hue1 + 180) % 360;
        
        gradient.addColorStop(0, `hsla(${hue1}, ${saturation}%, 70%, ${0.3 * intensity})`);
        gradient.addColorStop(0.5, `hsla(${hue2}, ${saturation}%, 60%, ${0.2 * intensity})`);
        gradient.addColorStop(1, `hsla(${hue3}, ${saturation}%, 50%, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        
        // Create flowing blob shapes
        ctx.moveTo(
          x + radius * Math.cos(0),
          y + radius * Math.sin(0)
        );
        
        for (let j = 0; j <= 360; j += 20) {
          const angle = j * Math.PI / 180;
          const radiusVariation = 1 + Math.sin(angle * 3 + time) * 0.2 * intensity;
          ctx.lineTo(
            x + radius * radiusVariation * Math.cos(angle),
            y + radius * radiusVariation * Math.sin(angle)
          );
        }
        
        ctx.fill();
      }
      
      animationFrameId = requestAnimationFrame(drawBackground);
    };
    
    drawBackground();
    
    return () => {
      window.removeEventListener('resize', updateCanvasSize);
      cancelAnimationFrame(animationFrameId);
    };
  }, [tripLevel, saturation]);

  // AI move handler
  useEffect(() => {
    if ((turn === 'b' || autoPlay) && gameState === 'playing' && !aiThinking) {
      const aiPlayer = turn;
      setAiThinking(true);
      
      const aiMoveTimer = setTimeout(() => {
        makeAIMove(aiPlayer);
        setAiThinking(false);
      }, moveDelay);
      
      return () => clearTimeout(aiMoveTimer);
    }
  }, [turn, autoPlay, gameState]);

  // Get board coordinates safely using ref
  const getBoardCoordinates = (row, col) => {
    if (!boardRef.current) return { x: 0, y: 0 };
    
    const rect = boardRef.current.getBoundingClientRect();
    const cellSize = rect.width / 8;
    
    return {
      x: rect.left + col * cellSize + cellSize / 2,
      y: rect.top + row * cellSize + cellSize / 2
    };
  };

  // Basic move validation without directly modifying state
  const getValidMoves = (row, col, currentBoard = board, currentTurn = turn) => {
    const piece = currentBoard[row][col];
    if (!piece) return [];
    
    const pieceType = piece[1];
    const pieceColor = piece[0];
    
    // Only allow moving pieces of current turn
    if (pieceColor !== currentTurn && !autoPlay) return [];
    
    const moves = [];
    
    // Simplified move logic for demo
    if (pieceType === 'p') { // Pawn
      const direction = pieceColor === 'w' ? -1 : 1;
      
      // Move forward one square
      if (row + direction >= 0 && row + direction < 8 && !currentBoard[row + direction][col]) {
        moves.push([row + direction, col]);
        
        // Move forward two squares from starting position
        if ((pieceColor === 'w' && row === 6) || (pieceColor === 'b' && row === 1)) {
          if (row + 2 * direction >= 0 && row + 2 * direction < 8 && !currentBoard[row + 2 * direction][col]) {
            moves.push([row + 2 * direction, col]);
          }
        }
      }
      
      // Capture diagonally
      for (let offset of [-1, 1]) {
        if (col + offset >= 0 && col + offset < 8 && row + direction >= 0 && row + direction < 8) {
          const targetPiece = currentBoard[row + direction][col + offset];
          if (targetPiece && targetPiece[0] !== pieceColor) {
            moves.push([row + direction, col + offset]);
          }
        }
      }
    } else if (pieceType === 'r') { // Rook
      // Horizontal and vertical movement
      for (let direction of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
        let [dr, dc] = direction;
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c]) {
            moves.push([r, c]);
          } else {
            if (currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
            break;
          }
          r += dr;
          c += dc;
        }
      }
    } else if (pieceType === 'n') { // Knight
      const knightMoves = [
        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
        [1, -2], [1, 2], [2, -1], [2, 1]
      ];
      
      for (let [dr, dc] of knightMoves) {
        const r = row + dr;
        const c = col + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c] || currentBoard[r][c][0] !== pieceColor) {
            moves.push([r, c]);
          }
        }
      }
    } else if (pieceType === 'b') { // Bishop
      // Diagonal movement
      for (let direction of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
        let [dr, dc] = direction;
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c]) {
            moves.push([r, c]);
          } else {
            if (currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
            break;
          }
          r += dr;
          c += dc;
        }
      }
    } else if (pieceType === 'q') { // Queen
      // Combine rook and bishop movement
      for (let direction of [
        [0, 1], [1, 0], [0, -1], [-1, 0],
        [1, 1], [1, -1], [-1, 1], [-1, -1]
      ]) {
        let [dr, dc] = direction;
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c]) {
            moves.push([r, c]);
          } else {
            if (currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
            break;
          }
          r += dr;
          c += dc;
        }
      }
    } else if (pieceType === 'k') { // King
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (!currentBoard[r][c] || currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
          }
        }
      }
    }
    
    return moves;
  };
  
  // Check if the king is in check (fixed version)
  const isInCheck = (color, testBoard = board) => {
    // Find the king
    let kingRow = -1;
    let kingCol = -1;
    
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (testBoard[r][c] === `${color}k`) {
          kingRow = r;
          kingCol = c;
          break;
        }
      }
      if (kingRow !== -1) break;
    }
    
    if (kingRow === -1) return false; // King not found
    
    // Check if any opponent piece can capture the king
    const opponent = color === 'w' ? 'b' : 'w';
    
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = testBoard[r][c];
        if (piece && piece[0] === opponent) {
          // Get valid moves for this opponent piece - use the current opponent color as turn
          const moves = getValidMoves(r, c, testBoard, opponent);
          
          // Check if any move can capture the king
          if (moves.some(([moveR, moveC]) => moveR === kingRow && moveC === kingCol)) {
            return true;
          }
        }
      }
    }
    
    return false;
  };

  // Execute a move on the board
  const executeMove = (fromRow, fromCol, toRow, toCol, currentBoard = board) => {
    // Create a deep copy of the board
    const newBoard = JSON.parse(JSON.stringify(currentBoard));
    const movingPiece = newBoard[fromRow][fromCol];
    
    // Capture logic
    if (newBoard[toRow][toCol]) {
      const capturedPiece = newBoard[toRow][toCol];
      setCapturedPieces(prev => {
        const newCaptured = { ...prev };
        newCaptured[movingPiece[0]].push(capturedPiece);
        return newCaptured;
      });
      
      // Create intense pulse effect on capture
      setPulseEffect(1);
    }
    
    // Move the piece
    newBoard[toRow][toCol] = movingPiece;
    newBoard[fromRow][fromCol] = null;
    
    // Update move history
    const pieceType = movingPiece[1].toUpperCase();
    const fromSquare = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}`;
    const toSquare = `${String.fromCharCode(97 + toCol)}${8 - toRow}`;
    setMoveHistory(prev => [...prev, `${pieceType} ${fromSquare}-${toSquare}`]);
    
    // Record last move for highlighting
    setLastMove({ from: [fromRow, fromCol], to: [toRow, toCol] });
    
    return newBoard;
  };

  const handleCellClick = (row, col) => {
    // Don't allow moves during AI turns or if game is over
    if ((turn === 'b' && !autoPlay) || gameState !== 'playing' || aiThinking) return;
    
    // If a piece is already selected
    if (selectedPiece) {
      const [selectedRow, selectedCol] = selectedPiece;
      
      // Check if clicked cell is a valid move
      const isValidMove = possibleMoves.some(
        ([moveRow, moveCol]) => moveRow === row && moveCol === col
      );
      
      if (isValidMove) {
        // Make the move
        const newBoard = executeMove(selectedRow, selectedCol, row, col);
        
        setBoard(newBoard);
        setSelectedPiece(null);
        setPossibleMoves([]);
        
        // Check if the move resulted in check
        const nextTurn = turn === 'w' ? 'b' : 'w';
        const inCheck = isInCheck(nextTurn, newBoard);
        
        setGameState(inCheck ? 'check' : 'playing');
        setTurn(nextTurn);
      } else {
        // If clicking on another piece of the same color, select that piece instead
        if (board[row][col] && board[row][col][0] === turn) {
          setSelectedPiece([row, col]);
          setPossibleMoves(getValidMoves(row, col));
        } else {
          // Clicked on an invalid square, deselect
          setSelectedPiece(null);
          setPossibleMoves([]);
        }
      }
    } else {
      // If no piece is selected, select the clicked piece if it belongs to the current player
      if (board[row][col] && board[row][col][0] === turn) {
        setSelectedPiece([row, col]);
        setPossibleMoves(getValidMoves(row, col));
      }
    }
  };
  
  // Calculate move score for AI
  const calculateMoveScore = (from, to, currentBoard = board) => {
    const [fromRow, fromCol] = from;
    const [toRow, toCol] = to;
    const piece = currentBoard[fromRow][fromCol];
    const pieceColor = piece[0];
    const pieceType = piece[1];
    const targetPiece = currentBoard[toRow][toCol];
    
    let score = 0;
    
    // Base piece values
    const pieceValues = { 'p': 10, 'n': 30, 'b': 30, 'r': 50, 'q': 90, 'k': 900 };
    
    // Add value for piece being moved
    score += pieceValues[pieceType] * 0.1;
    
    // Value captured pieces highly
    if (targetPiece) {
      score += pieceValues[targetPiece[1]] * 10;
    }
    
    // Favor center control for all pieces
    const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
    score += (4 - centerDistance) * 2;
    
    // Bonus for advancing pawns
    if (pieceType === 'p') {
      const advancementValue = pieceColor === 'w' ? (6 - toRow) : (toRow - 1);
      score += advancementValue * 2;
      
      // Extra bonus for pawns near promotion
      if ((pieceColor === 'w' && toRow <= 1) || (pieceColor === 'b' && toRow >= 6)) {
        score += 30;
      }
    }
    
    // Slightly randomize score to prevent predictable play
    score += Math.random() * 2;
    
    return score;
  };
  
  // Simple AI move generation
  const makeAIMove = (aiColor = 'b') => {
    if (gameState !== 'playing' && gameState !== 'check') return;
    
    const possibleAIMoves = [];
    
    // Find all possible moves for the AI's pieces
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] && board[row][col][0] === aiColor) {
          const moves = getValidMoves(row, col, board, aiColor);
          for (let [moveRow, moveCol] of moves) {
            // Create a test board to evaluate the move
            const testBoard = JSON.parse(JSON.stringify(board));
            testBoard[moveRow][moveCol] = testBoard[row][col];
            testBoard[row][col] = null;
            
            // Only consider moves that don't leave own king in check
            if (!isInCheck(aiColor, testBoard)) {
              possibleAIMoves.push({
                from: [row, col],
                to: [moveRow, moveCol],
                piece: board[row][col],
                capture: board[moveRow][moveCol],
                score: calculateMoveScore([row, col], [moveRow, moveCol], board)
              });
            }
          }
        }
      }
    }
    
    if (possibleAIMoves.length === 0) {
      // If no valid moves, check if king is in check (checkmate) or not (stalemate)
      if (isInCheck(aiColor)) {
        setGameState('checkmate');
      } else {
        setGameState('stalemate');
      }
      return;
    }
    
    // Sort moves by score (higher is better)
    possibleAIMoves.sort((a, b) => b.score - a.score);
    
    // Choose a move based on difficulty
    let selectedMove;
    
    if (difficulty === 'EASY') {
      // For EASY, pick a random move from the top 70% of moves
      const cutoff = Math.max(1, Math.floor(possibleAIMoves.length * 0.7));
      const randomIndex = Math.floor(Math.random() * cutoff);
      selectedMove = possibleAIMoves[randomIndex];
    } 
    else if (difficulty === 'MEDIUM') {
      // For MEDIUM, pick a random move from the top 40% of moves
      const cutoff = Math.max(1, Math.floor(possibleAIMoves.length * 0.4));
      const randomIndex = Math.floor(Math.random() * cutoff);
      selectedMove = possibleAIMoves[randomIndex];
    }
    else {
      // For HARD, always pick the best move
      selectedMove = possibleAIMoves[0];
    }
    
    // Make the selected move
    const newBoard = executeMove(
      selectedMove.from[0], 
      selectedMove.from[1], 
      selectedMove.to[0], 
      selectedMove.to[1]
    );
    
    setBoard(newBoard);
    
    // Check if the move resulted in check
    const nextTurn = aiColor === 'w' ? 'b' : 'w';
    const inCheck = isInCheck(nextTurn, newBoard);
    
    setGameState(inCheck ? 'check' : 'playing');
    setTurn(nextTurn);
  };
  
  const resetGame = () => {
    setBoard(initialBoard);
    setSelectedPiece(null);
    setPossibleMoves([]);
    setTurn('w');
    setGameState('playing');
    setCapturedPieces({ w: [], b: [] });
    setMoveHistory([]);
    setLastMove(null);
  };
  
  // Get cell background color with psychedelic effects
  const getCellColor = (row, col, isSelected, isPossibleMove, isLastMoveFrom, isLastMoveTo) => {
    const isLightSquare = (row + col) % 2 === 0;
    const baseHue = (hueRotation + (isLightSquare ? 30 : 0)) % 360;
    const baseSaturation = isLightSquare ? 20 : 40;
    const baseLightness = isLightSquare ? 80 : 50;
    
    // Add warping effect
    const time = Date.now() * 0.001;
    const warpFactor = tripLevel / 200; // More subtle at lower trip levels
    const warp = Math.sin(row + col + time) * warpFactor;
    
    let cellColor;
    
    if (isSelected) {
      cellColor = `hsl(${(baseHue + 120) % 360}, ${baseSaturation + 40}%, ${baseLightness + 10}%)`;
    } else if (isPossibleMove) {
      const captureBoost = board[row][col] ? 40 : 0;
      cellColor = `hsl(${(baseHue + 60) % 360}, ${baseSaturation + 60}%, ${baseLightness + captureBoost}%)`;
    } else if (isLastMoveFrom) {
      cellColor = `hsl(${(baseHue + 200) % 360}, ${baseSaturation + 20}%, ${baseLightness - 10}%)`;
    } else if (isLastMoveTo) {
      cellColor = `hsl(${(baseHue + 200) % 360}, ${baseSaturation + 30}%, ${baseLightness}%)`;
    } else {
      cellColor = `hsl(${baseHue}, ${baseSaturation + warp * 20}%, ${baseLightness + warp * 10}%)`;
    }
    
    return cellColor;
  };
  
  // Get piece style with trippy effects
  const getPieceStyle = (row, col, isSelected) => {
    const time = Date.now() * 0.001;
    const intensity = tripLevel / 100;
    
    // Base scale effect
    let scale = isSelected ? 1.3 : 1;
    
    // Add pulsing
    scale += Math.sin(time * 2 + row + col) * 0.1 * intensity;
    
    // Add piece distortion based on trip level
    const blurAmount = tripLevel > 70 ? (tripLevel - 70) / 30 * 3 : 0;
    
    // Glow effect on selected pieces
    const shadowColor = `hsl(${(hueRotation + row * 20 + col * 30) % 360}, 100%, 70%)`;
    const shadow = isSelected ? `0 0 20px ${shadowColor}` : 'none';
    
    return {
      transform: `scale(${scale})`,
      transition: 'transform 0.2s',
      filter: `blur(${blurAmount}px) hue-rotate(${row * 10 + col * 10}deg)`,
      textShadow: shadow
    };
  };
  
  // Toggle auto-play mode
  const toggleAutoPlay = () => {
    const newAutoPlay = !autoPlay;
    setAutoPlay(newAutoPlay);
    
    // If turning on auto-play and it's currently white's turn, make a move
    if (newAutoPlay && turn === 'w' && gameState === 'playing') {
      setTimeout(() => makeAIMove('w'), moveDelay);
    }
  };
  
  // Render rainbow glow around the board
  const getBoardGlowStyle = () => {
    const intensity = tripLevel / 100;
    const size = 20 + pulseEffect * 30;
    
    return {
      boxShadow: `
        0 0 ${size}px 0 rgba(255, 0, 0, ${0.3 * intensity}),
        0 0 ${size * 2}px 0 rgba(0, 255, 0, ${0.2 * intensity}),
        0 0 ${size * 3}px 0 rgba(0, 0, 255, ${0.1 * intensity})
      `,
      filter: `hue-rotate(${hueRotation}deg)`
    };
  };

  return (
    <div className="relative w-full h-screen overflow-hidden bg-black flex items-center justify-center">
      {/* Background canvas */}
      <canvas 
        ref={backgroundCanvasRef}
        className="absolute top-0 left-0 w-full h-full"
      />
      
      <div className="relative z-30 flex flex-col items-center">
        {/* Game title */}
        <h1 
          className="text-4xl font-bold mb-4 text-center"
          style={{ 
            color: `hsl(${hueRotation}, 100%, 70%)`,
            textShadow: `
              0 0 10px hsl(${hueRotation}, 100%, 50%),
              0 0 20px hsl(${(hueRotation + 60) % 360}, 100%, 50%),
              0 0 30px hsl(${(hueRotation + 180) % 360}, 100%, 50%)
            `,
            transform: `scale(${1 + pulseEffect * 0.2})`
          }}
        >
          LSD Trippy Amazing Chess
        </h1>
        
        {/* Game controls */}
        <div className="flex flex-wrap justify-center gap-4 mb-4 p-3 bg-black bg-opacity-50 rounded-lg">
          <div className="text-white">
            <label className="mr-2 font-bold">Difficulty:</label>
            <select 
              value={difficulty} 
              onChange={(e) => setDifficulty(e.target.value)}
              className="p-1 bg-transparent border rounded text-white"
              style={{ 
                borderColor: `hsl(${hueRotation}, 100%, 70%)`,
                backgroundColor: 'rgba(0, 0, 0, 0.7)'
              }}
            >
              <option>EASY</option>
              <option>MEDIUM</option>
              <option>HARD</option>
            </select>
          </div>
          
          <div className="text-white">
            <label className="mr-2 font-bold">Trip Level:</label>
            <input 
              type="range" 
              min="20" 
              max="100" 
              value={tripLevel} 
              onChange={(e) => setTripLevel(parseInt(e.target.value))}
              className="w-32"
            />
          </div>
          
          <div className="text-white">
            <label className="mr-2 font-bold">Auto-Play:</label>
            <button
              onClick={toggleAutoPlay}
              className={`px-3 py-1 rounded ${autoPlay ? 'bg-green-700' : 'bg-red-700'}`}
            >
              {autoPlay ? 'ON' : 'OFF'}
            </button>
          </div>
          
          <button
            onClick={resetGame}
            className="px-3 py-1 bg-blue-600 text-white rounded hover:bg-blue-700"
          >
            Reset Game
          </button>
        </div>
        
        <div className="text-center bg-black bg-opacity-50 px-4 py-1 rounded-full mb-2">
          <span className="text-white font-bold">
            {gameState === 'checkmate' ? (
              <span className="text-red-300">Checkmate! {turn === 'b' ? 'White' : 'Black'} wins!</span>
            ) : gameState === 'stalemate' ? (
              <span className="text-yellow-300">Stalemate! Game ends in a draw.</span>
            ) : gameState === 'check' ? (
              <span className="text-orange-300">{turn === 'w' ? 'White' : 'Black'} is in check!</span>
            ) : (
              <span style={{ color: `hsl(${turn === 'w' ? 60 : 240}, 100%, 80%)` }}>
                Turn: {turn === 'w' ? 'White' : 'Black'} {aiThinking ? ' (Thinking...)' : ''}
              </span>
            )}
          </span>
        </div>
        
        <div className="flex gap-4">
          {/* Captured white pieces */}
          <div 
            className="bg-black bg-opacity-30 p-2 rounded w-12 h-96 flex flex-col items-center"
            style={{ 
              borderLeft: `2px solid hsl(${hueRotation}, 70%, 60%)`,
              borderRight: `2px solid hsl(${(hueRotation + 180) % 360}, 70%, 60%)`
            }}
          >
            {capturedPieces.b.map((piece, i) => (
              <div 
                key={i} 
                className="text-2xl"
                style={{ 
                  color: 'white',
                  textShadow: `0 0 5px hsl(${(hueRotation + i * 20) % 360}, 100%, 70%)`
                }}
              >
                {PIECES[piece]}
              </div>
            ))}
          </div>
          
          {/* Chess board */}
          <div 
            ref={boardRef}
            className="relative chess-board"
            style={{ 
              ...getBoardGlowStyle(),
              transform: `scale(${1 + pulseEffect * 0.05})`,
              transition: 'transform 0.2s'
            }}
          >
            <div 
              className="grid grid-cols-8 border-4 border-gray-900 shadow-lg"
              style={{ 
                width: '480px', 
                height: '480px',
                borderColor: `hsl(${hueRotation}, 70%, 20%)`
              }}
            >
              {Array(8).fill().map((_, row) => (
                Array(8).fill().map((_, col) => {
                  const isSelected = selectedPiece && selectedPiece[0] === row && selectedPiece[1] === col;
                  const isPossibleMove = possibleMoves.some(
                    ([moveRow, moveCol]) => moveRow === row && moveCol === col
                  );
                  const isLastMoveFrom = lastMove && lastMove.from[0] === row && lastMove.from[1] === col;
                  const isLastMoveTo = lastMove && lastMove.to[0] === row && lastMove.to[1] === col;
                  
                  return (
                    <div
                      key={`${row}-${col}`}
                      className="flex items-center justify-center cursor-pointer relative"
                      style={{ 
                        backgroundColor: getCellColor(row, col, isSelected, isPossibleMove, isLastMoveFrom, isLastMoveTo),
                        boxShadow: isPossibleMove ? `inset 0 0 15px hsl(${(hueRotation + 60) % 360}, 100%, 70%)` : 'none'
                      }}
                      onClick={() => handleCellClick(row, col)}
                    >
                      {/* Coordinate labels */}
                      {col === 0 && (
                        <span className="absolute left-1 top-0 text-xs font-bold opacity-60">
                          {8 - row}
                        </span>
                      )}
                      {row === 7 && (
                        <span className="absolute right-1 bottom-0 text-xs font-bold opacity-60">
                          {String.fromCharCode(97 + col)}
                        </span>
                      )}
                      
                      {/* Chess pieces */}
                      {board[row][col] && (
                        <div 
                          className="text-4xl" 
                          style={getPieceStyle(row, col, isSelected)}
                        >
                          {PIECES[board[row][col]]}
                        </div>
                      )}
                      
                      {/* Highlight possible moves with pulsing circles */}
                      {isPossibleMove && (
                        <div 
                          className="absolute inset-0 flex items-center justify-center"
                          style={{ pointerEvents: 'none' }}
                        >
                          <div 
                            className="rounded-full"
                            style={{
                              width: board[row][col] ? '90%' : '30%',
                              height: board[row][col] ? '90%' : '30%',
                              border: `2px solid hsla(${(hueRotation + 120) % 360}, 100%, 70%, 0.7)`,
                              animation: 'pulse 1.5s infinite',
                              opacity: 0.8
                            }}
                          />
                        </div>
                      )}
                    </div>
                  );
                })
              ))}
            </div>
          </div>
          
          {/* Move history and captured black pieces */}
          <div className="flex flex-col h-96 gap-2">
            {/* Captured black pieces */}
            <div 
              className="bg-black bg-opacity-30 p-2 rounded w-12 flex flex-col items-center"
              style={{ 
                borderLeft: `2px solid hsl(${(hueRotation + 90) % 360}, 70%, 60%)`,
                borderRight: `2px solid hsl(${(hueRotation + 270) % 360}, 70%, 60%)`
              }}
            >
              {capturedPieces.w.map((piece, i) => (
                <div 
                  key={i} 
                  className="text-2xl"
                  style={{ 
                    color: 'black',
                    textShadow: `0 0 5px hsl(${(hueRotation + i * 20) % 360}, 100%, 70%)`
                  }}
                >
                  {PIECES[piece]}
                </div>
              ))}
            </div>
            
            {/* Move history */}
            <div 
              className="bg-black bg-opacity-50 p-2 rounded flex-grow overflow-y-auto"
              style={{
                borderTop: `2px solid hsl(${(hueRotation + 45) % 360}, 70%, 60%)`,
                borderBottom: `2px solid hsl(${(hueRotation + 225) % 360}, 70%, 60%)`
              }}
            >
              <h3 
                className="font-bold mb-1 text-center"
                style={{ color: `hsl(${hueRotation}, 100%, 80%)` }}
              >
                Move History
              </h3>
              {moveHistory.map((move, i) => (
                <div 
                  key={i} 
                  className="text-sm"
                  style={{ 
                    color: i % 2 === 0 ? 'white' : 'rgb(200, 200, 255)',
                    textShadow: `0 0 3px hsl(${(hueRotation + i * 10) % 360}, 70%, 50%)` 
                  }}
                >
                  {i % 2 === 0 ? `${Math.floor(i/2)+1}.` : ''} {move}
                </div>
              ))}
            </div>
          </div>
        </div>
      </div>
      
      {/* Game over overlay */}
      {(gameState === 'checkmate' || gameState === 'stalemate') && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 z-40">
          <div 
            className="p-8 rounded-lg text-center"
            style={{
              background: `radial-gradient(circle, 
                hsl(${hueRotation}, 60%, 20%),
                hsl(${(hueRotation + 180) % 360}, 60%, 10%)
              )`,
              border: `4px solid hsl(${hueRotation}, 100%, 50%)`,
              boxShadow: `
                0 0 20px hsl(${hueRotation}, 100%, 50%),
                0 0 40px hsl(${(hueRotation + 60) % 360}, 100%, 50%),
                0 0 60px hsl(${(hueRotation + 120) % 360}, 100%, 50%)
              `
            }}
          >
            <h2 
              className="text-4xl font-bold mb-4"
              style={{ 
                color: 'white',
                textShadow: `
                  0 0 10px hsl(${hueRotation}, 100%, 70%),
                  0 0 20px hsl(${(hueRotation + 120) % 360}, 100%, 70%)
                `
              }}
            >
              {gameState === 'checkmate' ? 'Checkmate!' : 'Stalemate!'}
            </h2>
            <p 
              className="text-2xl mb-6"
              style={{ 
                color: gameState === 'stalemate' ? 
                  `hsl(60, 100%, 80%)` : 
                  `hsl(${turn === 'b' ? 60 : 240}, 100%, 80%)` 
              }}
            >
              {gameState === 'checkmate' ? 
                `${turn === 'b' ? 'White' : 'Black'} wins!` : 
                'Game ends in a draw.'}
            </p>
            <button
              onClick={resetGame}
              className="py-3 px-8 rounded-full text-white font-bold text-xl transition-all"
              style={{ 
                background: `linear-gradient(45deg, 
                  hsl(${hueRotation}, 100%, 50%), 
                  hsl(${(hueRotation + 120) % 360}, 100%, 50%), 
                  hsl(${(hueRotation + 240) % 360}, 100%, 50%),
                  hsl(${hueRotation}, 100%, 50%)
                )`,
                backgroundSize: '300% 300%',
                animation: 'gradient-shift 2s linear infinite',
                boxShadow: `0 0 15px hsl(${hueRotation}, 100%, 50%)`,
                textShadow: '0 0 5px rgba(0, 0, 0, 0.5)'
              }}
            >
              Play Again
            </button>
          </div>
        </div>
      )}
      
      {/* CSS animations */}
      <style jsx>{`
        @keyframes pulse {
          0% { transform: scale(0.95); opacity: 0.7; }
          50% { transform: scale(1.05); opacity: 0.9; }
          100% { transform: scale(0.95); opacity: 0.7; }
        }
        
        @keyframes gradient-shift {
          0% { background-position: 0% 50%; }
          100% { background-position: 100% 50%; }
        }
      `}</style>
    </div>
  );
};

export default TripChess;
