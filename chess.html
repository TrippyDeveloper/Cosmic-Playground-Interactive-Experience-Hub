import React, { useState, useEffect, useRef } from 'react';
import _ from 'lodash';

// Chess piece Unicode characters
const PIECES = {
  'wk': '♔', 'wq': '♕', 'wr': '♖', 'wb': '♗', 'wn': '♘', 'wp': '♙',
  'bk': '♚', 'bq': '♛', 'br': '♜', 'bb': '♝', 'bn': '♞', 'bp': '♟'
};

// Initial board setup
const initialBoard = [
  ['br', 'bn', 'bb', 'bq', 'bk', 'bb', 'bn', 'br'],
  ['bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp', 'bp'],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  ['wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp', 'wp'],
  ['wr', 'wn', 'wb', 'wq', 'wk', 'wb', 'wn', 'wr']
];

const TripChess = () => {
  const [board, setBoard] = useState(initialBoard);
  const [selectedPiece, setSelectedPiece] = useState(null);
  const [possibleMoves, setPossibleMoves] = useState([]);
  const [turn, setTurn] = useState('w'); // 'w' for white, 'b' for black
  const [gameState, setGameState] = useState('playing'); // 'playing', 'check', 'checkmate'
  const [difficulty, setDifficulty] = useState('MEDIUM');
  const [tripLevel, setTripLevel] = useState(80);
  const [capturedPieces, setCapturedPieces] = useState({ w: [], b: [] });
  const [moveHistory, setMoveHistory] = useState([]);
  const [hueRotation, setHueRotation] = useState(0);
  const [saturation, setSaturation] = useState(100);
  const [pulseEffect, setPulseEffect] = useState(0);
  const [moveTrails, setMoveTrails] = useState([]);
  const [fractals, setFractals] = useState([]);
  const [showControls, setShowControls] = useState(true);
  const [lastMove, setLastMove] = useState(null);
  const [autoPlay, setAutoPlay] = useState(false);
  const [aiThinking, setAiThinking] = useState(false);
  const [moveDelay, setMoveDelay] = useState(1000);
  
  const canvasRef = useRef(null);
  const backgroundCanvasRef = useRef(null);
  const fractalCanvasRef = useRef(null);
  const trailsCanvasRef = useRef(null);
  
  // Generate initial fractals
  useEffect(() => {
    setFractals(Array(8).fill().map(() => ({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      size: Math.random() * 100 + 50,
      rotation: Math.random() * 360,
      speed: Math.random() * 0.5 + 0.1,
      hue: Math.random() * 360,
      complexity: Math.random() * 5 + 3
    })));
  }, []);
  
  // AI move handler
  useEffect(() => {
    if ((turn === 'b' || autoPlay) && gameState === 'playing') {
      const aiPlayer = turn;
      setAiThinking(true);
      
      const aiMoveTimer = setTimeout(() => {
        makeAIMove(aiPlayer);
        setAiThinking(false);
      }, moveDelay);
      
      return () => clearTimeout(aiMoveTimer);
    }
  }, [turn, autoPlay, gameState]);
  
  // Background animation with fractal patterns
  useEffect(() => {
    const canvas = backgroundCanvasRef.current;
    const fractalCanvas = fractalCanvasRef.current;
    if (!canvas || !fractalCanvas) return;
    
    const ctx = canvas.getContext('2d');
    const fractalCtx = fractalCanvas.getContext('2d');
    let animationFrameId;
    let time = 0;
    
    // Set canvas dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    fractalCanvas.width = window.innerWidth;
    fractalCanvas.height = window.innerHeight;
    
    const drawFractal = (x, y, size, depth, rotation, hue) => {
      if (depth <= 0) return;
      
      const intensity = tripLevel / 100;
      const branchLength = size * (0.7 + Math.sin(time * 0.2) * 0.1);
      
      fractalCtx.save();
      fractalCtx.translate(x, y);
      fractalCtx.rotate(rotation * Math.PI / 180);
      
      // Draw branch
      fractalCtx.strokeStyle = `hsla(${hue}, ${saturation}%, 50%, ${intensity * 0.5})`;
      fractalCtx.lineWidth = depth;
      fractalCtx.beginPath();
      fractalCtx.moveTo(0, 0);
      fractalCtx.lineTo(0, -branchLength);
      fractalCtx.stroke();
      
      // Draw sub-fractals
      const newX = 0;
      const newY = -branchLength;
      const newSize = size * 0.7;
      
      drawFractal(newX, newY, newSize, depth - 1, rotation - 30 + Math.sin(time) * 10, (hue + 20) % 360);
      drawFractal(newX, newY, newSize, depth - 1, rotation + 30 + Math.sin(time) * 10, (hue + 40) % 360);
      
      fractalCtx.restore();
    };
    
    const drawBackground = () => {
      time += 0.01;
      const intensity = tripLevel / 100;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw trippy background with flowing patterns
      for (let i = 0; i < 12; i++) {
        const radius = 150 + Math.sin(time * (i + 1) * 0.3) * 100 * intensity;
        const x = canvas.width / 2 + Math.cos(time * 0.5 * (i + 1)) * 200 * intensity;
        const y = canvas.height / 2 + Math.sin(time * 0.3 * (i + 1)) * 200 * intensity;
        
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
        const hue1 = (time * 30 + i * 30) % 360;
        const hue2 = (hue1 + 60) % 360;
        const hue3 = (hue1 + 180) % 360;
        
        gradient.addColorStop(0, `hsla(${hue1}, ${saturation}%, 70%, ${0.3 * intensity})`);
        gradient.addColorStop(0.5, `hsla(${hue2}, ${saturation}%, 60%, ${0.2 * intensity})`);
        gradient.addColorStop(1, `hsla(${hue3}, ${saturation}%, 50%, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        
        // Create flowing blob shapes
        ctx.moveTo(
          x + radius * Math.cos(0),
          y + radius * Math.sin(0)
        );
        
        for (let j = 0; j <= 360; j += 10) {
          const angle = j * Math.PI / 180;
          const radiusVariation = 1 + Math.sin(angle * 3 + time) * 0.2 * intensity;
          ctx.lineTo(
            x + radius * radiusVariation * Math.cos(angle),
            y + radius * radiusVariation * Math.sin(angle)
          );
        }
        
        ctx.fill();
      }
      
      // Draw moving wave patterns
      ctx.strokeStyle = `hsla(${(time * 50) % 360}, ${saturation}%, 50%, ${0.2 * intensity})`;
      ctx.lineWidth = 2;
      
      for (let wave = 0; wave < 5; wave++) {
        ctx.beginPath();
        for (let x = 0; x < canvas.width; x += 10) {
          const y = canvas.height / 2 
            + Math.sin(x * 0.01 + time + wave) * 50 * intensity
            + Math.cos(x * 0.02 - time * 1.5) * 30 * intensity;
          
          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      
      // Draw fractals
      fractalCtx.clearRect(0, 0, fractalCanvas.width, fractalCanvas.height);
      
      const newFractals = [...fractals];
      for (let i = 0; i < newFractals.length; i++) {
        const f = newFractals[i];
        
        // Move fractals
        f.x += Math.sin(time * f.speed) * 2;
        f.y += Math.cos(time * f.speed) * 2;
        f.rotation += 0.2;
        f.hue = (f.hue + 0.5) % 360;
        
        // Keep fractals in bounds
        if (f.x < -100) f.x = canvas.width + 100;
        if (f.x > canvas.width + 100) f.x = -100;
        if (f.y < -100) f.y = canvas.height + 100;
        if (f.y > canvas.height + 100) f.y = -100;
        
        // Draw only if trip level is high enough
        if (tripLevel > 40) {
          drawFractal(
            f.x, 
            f.y, 
            f.size * (intensity * 0.5 + 0.5), 
            Math.floor(f.complexity * (intensity * 0.5 + 0.5)), 
            f.rotation, 
            f.hue
          );
        }
      }
      
      setFractals(newFractals);
      
      animationFrameId = requestAnimationFrame(drawBackground);
    };
    
    drawBackground();
    
    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [tripLevel, saturation, fractals]);
  
  // Trails animation
  useEffect(() => {
    const canvas = trailsCanvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let animationFrameId;
    
    // Set canvas dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const drawTrails = () => {
      const intensity = tripLevel / 100;
      
      // Fade out existing trails
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw trails
      moveTrails.forEach((trail, index) => {
        const progress = trail.progress;
        const size = (1 - progress) * 40 * intensity;
        
        // Skip if too small
        if (size < 1) return;
        
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        
        // Glow effect
        const gradient = ctx.createRadialGradient(
          trail.x, trail.y, 0,
          trail.x, trail.y, size * 2
        );
        
        gradient.addColorStop(0, `hsla(${trail.hue}, ${saturation}%, 70%, ${(1 - progress) * 0.8})`);
        gradient.addColorStop(1, `hsla(${trail.hue}, ${saturation}%, 50%, 0)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(trail.x, trail.y, size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        
        // Update trail
        trail.progress += 0.01;
      });
      
      // Remove old trails
      setMoveTrails(prev => prev.filter(trail => trail.progress < 1));
      
      animationFrameId = requestAnimationFrame(drawTrails);
    };
    
    drawTrails();
    
    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [tripLevel, saturation, moveTrails]);
  
  // Color cycle effect
  useEffect(() => {
    const interval = setInterval(() => {
      setHueRotation(prev => (prev + 2) % 360);
      setSaturation(prev => 80 + Math.sin(Date.now() * 0.001) * 20);
    }, 50);
    
    return () => clearInterval(interval);
  }, []);
  
  // Pulse effect
  useEffect(() => {
    if (pulseEffect > 0) {
      setTimeout(() => setPulseEffect(prev => Math.max(0, prev - 0.05)), 30);
    }
  }, [pulseEffect]);

  // Basic move validation
  const getValidMoves = (row, col, currentBoard = board) => {
    const piece = currentBoard[row][col];
    if (!piece) return [];
    
    const pieceType = piece[1];
    const pieceColor = piece[0];
    
    // Only allow moving pieces of current turn
    if (pieceColor !== turn && !autoPlay) return [];
    
    const moves = [];
    
    // Simplified move logic for demo
    if (pieceType === 'p') { // Pawn
      const direction = pieceColor === 'w' ? -1 : 1;
      
      // Move forward one square
      if (row + direction >= 0 && row + direction < 8 && !currentBoard[row + direction][col]) {
        moves.push([row + direction, col]);
        
        // Move forward two squares from starting position
        if ((pieceColor === 'w' && row === 6) || (pieceColor === 'b' && row === 1)) {
          if (row + 2 * direction >= 0 && row + 2 * direction < 8 && !currentBoard[row + 2 * direction][col]) {
            moves.push([row + 2 * direction, col]);
          }
        }
      }
      
      // Capture diagonally
      for (let offset of [-1, 1]) {
        if (col + offset >= 0 && col + offset < 8 && row + direction >= 0 && row + direction < 8) {
          const targetPiece = currentBoard[row + direction][col + offset];
          if (targetPiece && targetPiece[0] !== pieceColor) {
            moves.push([row + direction, col + offset]);
          }
        }
      }
    } else if (pieceType === 'r') { // Rook
      // Horizontal and vertical movement
      for (let direction of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
        let [dr, dc] = direction;
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c]) {
            moves.push([r, c]);
          } else {
            if (currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
            break;
          }
          r += dr;
          c += dc;
        }
      }
    } else if (pieceType === 'n') { // Knight
      const knightMoves = [
        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
        [1, -2], [1, 2], [2, -1], [2, 1]
      ];
      
      for (let [dr, dc] of knightMoves) {
        const r = row + dr;
        const c = col + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c] || currentBoard[r][c][0] !== pieceColor) {
            moves.push([r, c]);
          }
        }
      }
    } else if (pieceType === 'b') { // Bishop
      // Diagonal movement
      for (let direction of [[1, 1], [1, -1], [-1, 1], [-1, -1]]) {
        let [dr, dc] = direction;
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c]) {
            moves.push([r, c]);
          } else {
            if (currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
            break;
          }
          r += dr;
          c += dc;
        }
      }
    } else if (pieceType === 'q') { // Queen
      // Combine rook and bishop movement
      for (let direction of [
        [0, 1], [1, 0], [0, -1], [-1, 0],
        [1, 1], [1, -1], [-1, 1], [-1, -1]
      ]) {
        let [dr, dc] = direction;
        let r = row + dr;
        let c = col + dc;
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
          if (!currentBoard[r][c]) {
            moves.push([r, c]);
          } else {
            if (currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
            break;
          }
          r += dr;
          c += dc;
        }
      }
    } else if (pieceType === 'k') { // King
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          
          const r = row + dr;
          const c = col + dc;
          if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (!currentBoard[r][c] || currentBoard[r][c][0] !== pieceColor) {
              moves.push([r, c]);
            }
          }
        }
      }
    }
    
    return moves;
  };
  
  // Check if the king is in check
  const isInCheck = (color, testBoard = board) => {
    // Find the king
    let kingRow = -1;
    let kingCol = -1;
    
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if (testBoard[r][c] === `${color}k`) {
          kingRow = r;
          kingCol = c;
          break;
        }
      }
      if (kingRow !== -1) break;
    }
    
    if (kingRow === -1) return false; // King not found (shouldn't happen in a valid game)
    
    // Check if any opponent piece can capture the king
    const opponent = color === 'w' ? 'b' : 'w';
    
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = testBoard[r][c];
        if (piece && piece[0] === opponent) {
          // Temporarily set turn to opponent to check their moves
          const originalTurn = turn;
          setTurn(opponent);
          
          // Get valid moves for this opponent piece
          const moves = getValidMoves(r, c, testBoard);
          
          // Reset turn
          setTurn(originalTurn);
          
          // Check if any move can capture the king
          if (moves.some(([moveR, moveC]) => moveR === kingRow && moveC === kingCol)) {
            return true;
          }
        }
      }
    }
    
    return false;
  };
  
  // Convert board coordinates to screen coordinates
  const getBoardCoordinates = (row, col) => {
    const boardElement = document.querySelector('.chess-board');
    if (!boardElement) return { x: 0, y: 0 };
    
    const rect = boardElement.getBoundingClientRect();
    const cellSize = rect.width / 8;
    
    return {
      x: rect.left + col * cellSize + cellSize / 2,
      y: rect.top + row * cellSize + cellSize / 2
    };
  };
  
  // Add a new trail for piece movement
  const addMoveTrail = (fromRow, fromCol, toRow, toCol, hue) => {
    const fromCoord = getBoardCoordinates(fromRow, fromCol);
    const toCoord = getBoardCoordinates(toRow, toCol);
    
    // Create trail points along the path
    const trailPoints = 15; // More trail points for smoother effect
    const newTrails = [];
    
    for (let i = 0; i < trailPoints; i++) {
      const progress = i / trailPoints;
      
      // Add some randomness to trail positions for a more organic feel
      const jitter = tripLevel / 200; // More trippy = more jitter
      const jitterX = (Math.random() - 0.5) * jitter * 40;
      const jitterY = (Math.random() - 0.5) * jitter * 40;
      
      newTrails.push({
        x: fromCoord.x + (toCoord.x - fromCoord.x) * progress + jitterX,
        y: fromCoord.y + (toCoord.y - fromCoord.y) * progress + jitterY,
        hue: (hue + i * 15) % 360,
        progress: Math.random() * 0.2 // Stagger the start times
      });
    }
    
    setMoveTrails(prev => [...prev, ...newTrails]);
  };

  // Execute a move on the board
  const executeMove = (fromRow, fromCol, toRow, toCol, currentBoard = board) => {
    // Create a deep copy of the board
    const newBoard = JSON.parse(JSON.stringify(currentBoard));
    const movingPiece = newBoard[fromRow][fromCol];
    
    // Create move trail effect
    addMoveTrail(fromRow, fromCol, toRow, toCol, 
                 movingPiece[0] === 'w' ? hueRotation : (hueRotation + 180) % 360);
    
    // Capture logic
    if (newBoard[toRow][toCol]) {
      const capturedPiece = newBoard[toRow][toCol];
      setCapturedPieces(prev => {
        const newCaptured = { ...prev };
        newCaptured[movingPiece[0]].push(capturedPiece);
        return newCaptured;
      });
      
      // Create intense pulse effect on capture
      setPulseEffect(1);
    }
    
    // Move the piece
    newBoard[toRow][toCol] = movingPiece;
    newBoard[fromRow][fromCol] = null;
    
    // Update move history
    const pieceType = movingPiece[1].toUpperCase();
    const fromSquare = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}`;
    const toSquare = `${String.fromCharCode(97 + toCol)}${8 - toRow}`;
    setMoveHistory(prev => [...prev, `${pieceType} ${fromSquare}-${toSquare}`]);
    
    // Record last move for highlighting
    setLastMove({ from: [fromRow, fromCol], to: [toRow, toCol] });
    
    return newBoard;
  };

  const handleCellClick = (row, col) => {
    // Don't allow moves during AI turns or if game is over
    if (turn === 'b' && !autoPlay) return;
    if (gameState !== 'playing') return;
    if (aiThinking) return;
    
    // If a piece is already selected
    if (selectedPiece) {
      const [selectedRow, selectedCol] = selectedPiece;
      
      // Check if clicked cell is a valid move
      const isValidMove = possibleMoves.some(
        ([moveRow, moveCol]) => moveRow === row && moveCol === col
      );
      
      if (isValidMove) {
        // Make the move
        const newBoard = executeMove(selectedRow, selectedCol, row, col);
        
        setBoard(newBoard);
        setSelectedPiece(null);
        setPossibleMoves([]);
        
        // Check if the move resulted in check
        const nextTurn = turn === 'w' ? 'b' : 'w';
        const inCheck = isInCheck(nextTurn, newBoard);
        
        if (inCheck) {
          setGameState('check');
        } else {
          setGameState('playing');
        }
        
        // Switch turns
        setTurn(nextTurn);
      } else {
        // If clicking on another piece of the same color, select that piece instead
        if (board[row][col] && board[row][col][0] === turn) {
          setSelectedPiece([row, col]);
          setPossibleMoves(getValidMoves(row, col));
        } else {
          // Clicked on an invalid square, deselect
          setSelectedPiece(null);
          setPossibleMoves([]);
        }
      }
    } else {
      // If no piece is selected, select the clicked piece if it belongs to the current player
      if (board[row][col] && board[row][col][0] === turn) {
        setSelectedPiece([row, col]);
        setPossibleMoves(getValidMoves(row, col));
      }
    }
  };
  
  // Simple AI move generation
  const makeAIMove = (aiColor = 'b') => {
    if (gameState !== 'playing' && gameState !== 'check') return;
    
    const possibleAIMoves = [];
    
    // Find all possible moves for the AI's pieces
    for (let row = 0; row < 8; row++) {
      for (let col = 0; col < 8; col++) {
        if (board[row][col] && board[row][col][0] === aiColor) {
          const moves = getValidMoves(row, col);
          for (let [moveRow, moveCol] of moves) {
            // Create a test board to evaluate the move
            const testBoard = JSON.parse(JSON.stringify(board));
            testBoard[moveRow][moveCol] = testBoard[row][col];
            testBoard[row][col] = null;
            
            // Only consider moves that don't leave own king in check
            if (!isInCheck(aiColor, testBoard)) {
              possibleAIMoves.push({
                from: [row, col],
                to: [moveRow, moveCol],
                piece: board[row][col],
                capture: board[moveRow][moveCol],
                score: calculateMoveScore([row, col], [moveRow, moveCol], board)
              });
            }
          }
        }
      }
    }
    
    if (possibleAIMoves.length === 0) {
      // If no valid moves, check if king is in check (checkmate) or not (stalemate)
      if (isInCheck(aiColor)) {
        setGameState('checkmate');
      } else {
        setGameState('stalemate');
      }
      return;
    }
    
    // Sort moves by score (higher is better)
    possibleAIMoves.sort((a, b) => b.score - a.score);
    
    // Choose a move based on difficulty
    let selectedMove;
    
    if (difficulty === 'EASY') {
      // For EASY, pick a random move from the top 70% of moves
      const cutoff = Math.max(1, Math.floor(possibleAIMoves.length * 0.7));
      const randomIndex = Math.floor(Math.random() * cutoff);
      selectedMove = possibleAIMoves[randomIndex];
    } 
    else if (difficulty === 'MEDIUM') {
      // For MEDIUM, pick a random move from the top 40% of moves
      const cutoff = Math.max(1, Math.floor(possibleAIMoves.length * 0.4));
      const randomIndex = Math.floor(Math.random() * cutoff);
      selectedMove = possibleAIMoves[randomIndex];
    }
    else {
      // For HARD, always pick the best move
      selectedMove = possibleAIMoves[0];
    }
    
    // Make the selected move
    const newBoard = executeMove(
      selectedMove.from[0], 
      selectedMove.from[1], 
      selectedMove.to[0], 
      selectedMove.to[1]
    );
    
    setBoard(newBoard);
    
    // Check if the move resulted in check
    const nextTurn = aiColor === 'w' ? 'b' : 'w';
    const inCheck = isInCheck(nextTurn, newBoard);
    
    if (inCheck) {
      setGameState('check');
    } else {
      setGameState('playing');
    }
    
    // Switch turns
    setTurn(nextTurn);
  };
  
  // Calculate move score for AI
  const calculateMoveScore = (from, to, currentBoard = board) => {
    const [fromRow, fromCol] = from;
    const [toRow, toCol] = to;
    const piece = currentBoard[fromRow][fromCol];
    const pieceColor = piece[0];
    const pieceType = piece[1];
    const targetPiece = currentBoard[toRow][toCol];
    
    let score = 0;
    
    // Base piece values
    const pieceValues = { 'p': 10, 'n': 30, 'b': 30, 'r': 50, 'q': 90, 'k': 900 };
    
    // Add value for piece being moved
    score += pieceValues[pieceType] * 0.1;
    
    // Value captured pieces highly
    if (targetPiece) {
      score += pieceValues[targetPiece[1]] * 10;
    }
    
    // Favor center control for all pieces
    const centerDistance = Math.abs(toRow - 3.5) + Math.abs(toCol - 3.5);
    score += (4 - centerDistance) * 2;
    
    // Bonus for advancing pawns
    if (pieceType === 'p') {
      const advancementValue = pieceColor === 'w' ? (6 - toRow) : (toRow - 1);
      score += advancementValue * 2;
      
      // Extra bonus for pawns near promotion
      if ((pieceColor === 'w' && toRow <= 1) || (pieceColor === 'b' && toRow >= 6)) {
        score += 30;
      }
    }
    
    // Knights are more valuable in crowded positions
    if (pieceType === 'n') {
      let crowdedSquares = 0;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (currentBoard[r][c]) crowdedSquares++;
        }
      }
      if (crowdedSquares > 20) score += 5;
    }
    
    // Bishops and queens like open diagonals
    if (pieceType === 'b' || pieceType === 'q') {
      const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
      let openDiagonals = 0;
      
      for (let [dr, dc] of directions) {
        let r = toRow + dr;
        let c = toCol + dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8 && !currentBoard[r][c]) {
          openDiagonals++;
          r += dr;
          c += dc;
        }
      }
      
      score += openDiagonals * (pieceType === 'b' ? 1 : 0.5);
    }
    
    // Rooks and queens like open files
    if (pieceType === 'r' || pieceType === 'q') {
      const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
      let openLines = 0;
      
      for (let [dr, dc] of directions) {
        let r = toRow + dr;
        let c = toCol + dc;
        while (r >= 0 && r < 8 && c >= 0 && c < 8 && !currentBoard[r][c]) {
          openLines++;
          r += dr;
          c += dc;
        }
      }
      
      score += openLines * (pieceType === 'r' ? 1 : 0.5);
    }
    
    // King safety in early/middle game
    if (pieceType === 'k') {
      // Count number of pieces to determine game phase
      let pieceCount = 0;
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (currentBoard[r][c]) pieceCount++;
        }
      }
      
      // Early/middle game: keep king safe
      if (pieceCount > 20) {
        // Penalize moving king to center
        score -= (4 - centerDistance) * 5;
        
        // Bonus for king in corner or edge
        if (toRow === 0 || toRow === 7 || toCol === 0 || toCol === 7) {
          score += 10;
        }
      } 
      // Endgame: king should be active
      else {
        // In endgame, king should move toward center
        score += (4 - centerDistance) * 3;
      }
    }
    
    // Slightly randomize score to prevent predictable play
    score += Math.random() * 2;
    
    return score;
  };
  
  const resetGame = () => {
    setBoard(initialBoard);
    setSelectedPiece(null);
    setPossibleMoves([]);
    setTurn('w');
    setGameState('playing');
    setCapturedPieces({ w: [], b: [] });
    setMoveHistory([]);
    setLastMove(null);
  };
  
  // Get cell background color with psychedelic effects
  const getCellColor = (row, col, isSelected, isPossibleMove, isLastMoveFrom, isLastMoveTo) => {
    const isLightSquare = (row + col) % 2 === 0;
    const baseHue = (hueRotation + (isLightSquare ? 30 : 0)) % 360;
    const baseSaturation = isLightSquare ? 20 : 40;
    const baseLightness = isLightSquare ? 80 : 50;
    
    // Add warping effect
    const time = Date.now() * 0.001;
    const warpFactor = tripLevel / 200; // More subtle at lower trip levels
    const warp = Math.sin(row + col + time) * warpFactor;
    
    let cellColor;
    
    if (isSelected) {
      cellColor = `hsl(${(baseHue + 120) % 360}, ${baseSaturation + 40}%, ${baseLightness + 10}%)`;
    } else if (isPossibleMove) {
      const captureBoost = board[row][col] ? 40 : 0;
      cellColor = `hsl(${(baseHue + 60) % 360}, ${baseSaturation + 60}%, ${baseLightness + captureBoost}%)`;
    } else if (isLastMoveFrom) {
      cellColor = `hsl(${(baseHue + 200) % 360}, ${baseSaturation + 20}%, ${baseLightness - 10}%)`;
    } else if (isLastMoveTo) {
      cellColor = `hsl(${(baseHue + 200) % 360}, ${baseSaturation + 30}%, ${baseLightness}%)`;
    } else {
      cellColor = `hsl(${baseHue}, ${baseSaturation + warp * 20}%, ${baseLightness + warp * 10}%)`;
    }
    
    return cellColor;
  };
  
  // Get piece style with trippy effects
  const getPieceStyle = (row, col, isSelected) => {
    const time = Date.now() * 0.001;
    const intensity = tripLevel / 100;
    
    // Base scale effect
    let scale = isSelected ? 1.3 : 1;
    
    // Add pulsing
    scale += Math.sin(time * 2 + row + col) * 0.1 * intensity;
    
    // Add piece distortion based on trip level
    const blurAmount = tripLevel > 70 ? (tripLevel - 70) / 30 * 3 : 0;
    
    // Glow effect on selected pieces
    const shadowColor = `hsl(${(hueRotation + row * 20 + col * 30) % 360}, 100%, 70%)`;
    const shadow = isSelected ? `0 0 20px ${shadowColor}` : 'none';
    
    return {
      transform: `scale(${scale})`,
      transition: 'transform 0.2s',
      filter: `blur(${blurAmount}px) hue-rotate(${row * 10 + col * 10}deg)`,
      textShadow: shadow
    };
  };
  
  // Toggle auto-play mode
  const toggleAutoPlay = () => {
    const newAutoPlay = !autoPlay;
    setAutoPlay(newAutoPlay);
    
    // If turning on auto-play and it's currently white's turn, make a move
    if (newAutoPlay && turn === 'w' && gameState === 'playing') {
      setTimeout(() => makeAIMove('w'), moveDelay);
    }
  };
  
  // Render rainbow glow around the board
  const getBoardGlowStyle = () => {
    const intensity = tripLevel / 100;
    const size = 20 + pulseEffect * 30;
    
    return {
      boxShadow: `
        0 0 ${size}px 0 rgba(255, 0, 0, ${0.3 * intensity}),
        0 0 ${size * 2}px 0 rgba(0, 255, 0, ${0.2 * intensity}),
        0 0 ${size * 3}px 0 rgba(0, 0, 255, ${0.1 * intensity})
      `,
      filter: `hue-rotate(${hueRotation}deg)`
    };
  };

  return (
    <div className="relative w-full h-screen overflow-hidden bg-black flex items-center justify-center">
      {/* Background canvases */}
      <canvas 
        ref={backgroundCanvasRef}
        className="absolute top-0 left-0 w-full h-full"
      />
      <canvas 
        ref={fractalCanvasRef}
        className="absolute top-0 left-0 w-full h-full z-10"
      />
      <canvas 
        ref={trailsCanvasRef}
        className="absolute top-0 left-0 w-full h-full z-20"
      />
      
      <div className="relative z-30 flex flex-col items-center">
        {/* Game title */}
        <h1 
          className="text-5xl font-bold mb-4 text-center"
          style={{ 
            color: `hsl(${hueRotation}, 100%, 70%)`,
            textShadow: `
              0 0 10px hsl(${hueRotation}, 100%, 50%),
              0 0 20px hsl(${(hueRotation + 60) % 360}, 100%, 50%),
              0 0 30px hsl(${(hueRotation + 180) % 360}, 100%, 50%)
            `,
            transform: `scale(${1 + pulseEffect * 0.2})`
          }}
        >
          LSD Trippy Amazing Chess
        </h1>
        
        {/* Game controls */}
        {showControls && (
          <div className="flex flex-wrap justify-center gap-4 mb-4 p-3 bg-black bg-opacity-50 rounded-lg">
            <div className="text-white">
              <label className="mr-2 font-bold">Difficulty:</label>
              <select 
                value={difficulty} 
                onChange={(e) => setDifficulty(e.target.value)}
                className="p-1 bg-transparent border rounded text-white"
                style={{ 
                  borderColor: `hsl(${hueRotation}, 100%, 70%)`,
                  backgroundColor: 'rgba(0, 0, 0, 0.7)'
                }}
              >
                <option>EASY</option>
                <option>MEDIUM</option>
                <option>HARD</option>
              </select>
            </div>
            
            <div className="text-white">
              <label className="mr-2 font-bold">Trip Level:</label>
              <input 
                type="range" 
                min="20" 
                max="100" 
                value={tripLevel} 
                onChange={(e) => setTripLevel(parseInt(e.target.value))}
                className="w-32"
              />
            </div>
            
            <div className="text-white">
              <label className="mr-2 font-bold">Move Speed:</label>
              <select 
                value={moveDelay} 
                onChange={(e) => setMoveDelay(parseInt(e.target.value))}
                className="p-1 bg-transparent border rounded text-white"
                style={{ 
                  borderColor: `hsl(${hueRotation}, 100%, 70%)`,
                  backgroundColor: 'rgba(0, 0, 0, 0.7)'
                }}
              >
                <option value="2000">Slow</option>
                <option value="1000">Medium</option>
                <option value="500">Fast</option>
              </select>
            </div>
            
            <div className="text-white">
              <label className="mr-2 font-bold">Auto-Play:</label>
              <button
                onClick={toggleAutoPlay}
                className={`px-3 py-1 rounded ${autoPlay ? 'bg-green-700' : 'bg-red-700'}`}
              >
                {autoPlay ? 'ON' : 'OFF'}
              </button>
            </div>
            
            <button
              onClick={() => setShowControls(false)}
              className="text-white hover:text-red-300 transition-colors"
            >
              Hide Controls
            </button>
          </div>
        )}
        
        {!showControls && (
          <button
            onClick={() => setShowControls(true)}
            className="mb-2 text-white hover:text-green-300 transition-colors"
          >
            Show Controls
          </button>
        )}
        
        <div className="text-center bg-black bg-opacity-50 px-4 py-1 rounded-full mb-2">
          <span className="text-white font-bold">
            {gameState === 'checkmate' ? (
              <span className="text-red-300">Checkmate! {turn === 'b' ? 'White' : 'Black'} wins!</span>
            ) : gameState === 'stalemate' ? (
              <span className="text-yellow-300">Stalemate! Game ends in a draw.</span>
            ) : gameState === 'check' ? (
              <span className="text-orange-300">{turn === 'w' ? 'White' : 'Black'} is in check!</span>
            ) : (
              <span style={{ color: `hsl(${turn === 'w' ? 60 : 240}, 100%, 80%)` }}>
                Turn: {turn === 'w' ? 'White' : 'Black'} {aiThinking ? ' (Thinking...)' : ''}
              </span>
            )}
          </span>
        </div>
        
        <div className="flex gap-4">
          {/* Captured white pieces */}
          <div 
            className="bg-black bg-opacity-30 p-2 rounded w-12 h-96 flex flex-col items-center"
            style={{ 
              borderLeft: `2px solid hsl(${hueRotation}, 70%, 60%)`,
              borderRight: `2px solid hsl(${(hueRotation + 180) % 360}, 70%, 60%)`
            }}
          >
            {capturedPieces.b.map((piece, i) => (
              <div 
                key={i} 
                className="text-2xl"
                style={{ 
                  color: 'white',
                  textShadow: `0 0 5px hsl(${(hueRotation + i * 20) % 360}, 100%, 70%)`
                }}
              >
                {PIECES[piece]}
              </div>
            ))}
          </div>
          
          {/* Chess board */}
          <div 
            className="relative chess-board"
            style={{ 
              ...getBoardGlowStyle(),
              transform: `scale(${1 + pulseEffect * 0.05})`,
              transition: 'transform 0.2s'
            }}
          >
            <div 
              className="grid grid-cols-8 border-4 border-gray-900 shadow-lg"
              style={{ 
                width: '480px', 
                height: '480px',
                borderColor: `hsl(${hueRotation}, 70%, 20%)`
              }}
            >
              {Array(8).fill().map((_, row) => (
                Array(8).fill().map((_, col) => {
                  const isSelected = selectedPiece && selectedPiece[0] === row && selectedPiece[1] === col;
                  const isPossibleMove = possibleMoves.some(
                    ([moveRow, moveCol]) => moveRow === row && moveCol === col
                  );
                  const isLastMoveFrom = lastMove && lastMove.from[0] === row && lastMove.from[1] === col;
                  const isLastMoveTo = lastMove && lastMove.to[0] === row && lastMove.to[1] === col;
                  
                  return (
                    <div
                      key={`${row}-${col}`}
                      className="flex items-center justify-center cursor-pointer relative"
                      style={{ 
                        backgroundColor: getCellColor(row, col, isSelected, isPossibleMove, isLastMoveFrom, isLastMoveTo),
                        boxShadow: isPossibleMove ? `inset 0 0 15px hsl(${(hueRotation + 60) % 360}, 100%, 70%)` : 'none'
                      }}
                      onClick={() => handleCellClick(row, col)}
                    >
                      {/* Coordinate labels */}
                      {col === 0 && (
                        <span className="absolute left-1 top-0 text-xs font-bold opacity-60">
                          {8 - row}
                        </span>
                      )}
                      {row === 7 && (
                        <span className="absolute right-1 bottom-0 text-xs font-bold opacity-60">
                          {String.fromCharCode(97 + col)}
                        </span>
                      )}
                      
                      {/* Chess pieces */}
                      {board[row][col] && (
                        <div 
                          className="text-4xl" 
                          style={getPieceStyle(row, col, isSelected)}
                        >
                          {PIECES[board[row][col]]}
                        </div>
                      )}
                      
                      {/* Highlight possible moves with pulsing circles */}
                      {isPossibleMove && (
                        <div 
                          className="absolute inset-0 flex items-center justify-center"
                          style={{ pointerEvents: 'none' }}
                        >
                          <div 
                            className="rounded-full"
                            style={{
                              width: board[row][col] ? '90%' : '30%',
                              height: board[row][col] ? '90%' : '30%',
                              border: `2px solid hsla(${(hueRotation + 120) % 360}, 100%, 70%, 0.7)`,
                              animation: 'pulse 1.5s infinite',
                              opacity: 0.8
                            }}
                          />
                        </div>
                      )}
                    </div>
                  );
                })
              ))}
            </div>
          </div>
          
          {/* Move history and captured black pieces */}
          <div className="flex flex-col h-96 gap-2">
            {/* Captured black pieces */}
            <div 
              className="bg-black bg-opacity-30 p-2 rounded w-12 flex flex-col items-center"
              style={{ 
                borderLeft: `2px solid hsl(${(hueRotation + 90) % 360}, 70%, 60%)`,
                borderRight: `2px solid hsl(${(hueRotation + 270) % 360}, 70%, 60%)`
              }}
            >
              {capturedPieces.w.map((piece, i) => (
                <div 
                  key={i} 
                  className="text-2xl"
                  style={{ 
                    color: 'black',
                    textShadow: `0 0 5px hsl(${(hueRotation + i * 20) % 360}, 100%, 70%)`
                  }}
                >
                  {PIECES[piece]}
                </div>
              ))}
            </div>
            
            {/* Move history */}
            <div 
              className="bg-black bg-opacity-50 p-2 rounded flex-grow overflow-y-auto"
              style={{
                borderTop: `2px solid hsl(${(hueRotation + 45) % 360}, 70%, 60%)`,
                borderBottom: `2px solid hsl(${(hueRotation + 225) % 360}, 70%, 60%)`
              }}
            >
              <h3 
                className="font-bold mb-1 text-center"
                style={{ color: `hsl(${hueRotation}, 100%, 80%)` }}
              >
                Move History
              </h3>
              {moveHistory.map((move, i) => (
                <div 
                  key={i} 
                  className="text-sm"
                  style={{ 
                    color: i % 2 === 0 ? 'white' : 'rgb(200, 200, 255)',
                    textShadow: `0 0 3px hsl(${(hueRotation + i * 10) % 360}, 70%, 50%)` 
                  }}
                >
                  {i % 2 === 0 ? `${Math.floor(i/2)+1}.` : ''} {move}
                </div>
              ))}
            </div>
          </div>
        </div>
        
        <div className="flex gap-4 mt-4">
          <button 
            onClick={resetGame}
            className="py-2 px-6 rounded-full font-bold transition-all"
            style={{ 
              background: `linear-gradient(45deg, 
                hsl(${hueRotation}, 100%, 50%), 
                hsl(${(hueRotation + 60) % 360}, 100%, 50%), 
                hsl(${(hueRotation + 120) % 360}, 100%, 50%), 
                hsl(${(hueRotation + 180) % 360}, 100%, 50%), 
                hsl(${(hueRotation + 240) % 360}, 100%, 50%),
                hsl(${(hueRotation + 300) % 360}, 100%, 50%),
                hsl(${hueRotation}, 100%, 50%)
              )`,
              backgroundSize: '400% 400%',
              animation: 'gradient-shift 3s linear infinite',
              color: 'white',
              textShadow: '0 0 5px rgba(0, 0, 0, 0.5)',
              boxShadow: `0 0 20px hsl(${hueRotation}, 100%, 50%)`,
              transform: `scale(${1 + Math.sin(Date.now() * 0.003) * 0.05})`
            }}
          >
            Reset Game
          </button>
          
          <button 
            onClick={toggleAutoPlay}
            className="py-2 px-6 rounded-full font-bold transition-all"
            style={{ 
              background: autoPlay ? 
                `linear-gradient(45deg, hsl(120, 100%, 30%), hsl(140, 100%, 40%))` : 
                `linear-gradient(45deg, hsl(0, 100%, 40%), hsl(20, 100%, 50%))`,
              color: 'white',
              textShadow: '0 0 5px rgba(0, 0, 0, 0.5)',
              boxShadow: `0 0 20px hsl(${autoPlay ? 120 : 0}, 100%, 50%)`,
            }}
          >
            {autoPlay ? 'Stop Auto-Play' : 'Start Auto-Play'}
          </button>
        </div>
      </div>
      
      {/* Game over overlay */}
      {(gameState === 'checkmate' || gameState === 'stalemate') && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-70 z-40">
          <div 
            className="p-8 rounded-lg text-center"
            style={{
              background: `radial-gradient(circle, 
                hsl(${hueRotation}, 60%, 20%),
                hsl(${(hueRotation + 180) % 360}, 60%, 10%)
              )`,
              border: `4px solid hsl(${hueRotation}, 100%, 50%)`,
              boxShadow: `
                0 0 20px hsl(${hueRotation}, 100%, 50%),
                0 0 40px hsl(${(hueRotation + 60) % 360}, 100%, 50%),
                0 0 60px hsl(${(hueRotation + 120) % 360}, 100%, 50%)
              `
            }}
          >
            <h2 
              className="text-4xl font-bold mb-4"
              style={{ 
                color: 'white',
                textShadow: `
                  0 0 10px hsl(${hueRotation}, 100%, 70%),
                  0 0 20px hsl(${(hueRotation + 120) % 360}, 100%, 70%)
                `
              }}
            >
              {gameState === 'checkmate' ? 'Checkmate!' : 'Stalemate!'}
            </h2>
            <p 
              className="text-2xl mb-6"
              style={{ 
                color: gameState === 'stalemate' ? 
                  `hsl(60, 100%, 80%)` : 
                  `hsl(${turn === 'b' ? 60 : 240}, 100%, 80%)` 
              }}
            >
              {gameState === 'checkmate' ? 
                `${turn === 'b' ? 'White' : 'Black'} wins!` : 
                'Game ends in a draw.'}
            </p>
            <button
              onClick={resetGame}
              className="py-3 px-8 rounded-full text-white font-bold text-xl transition-all"
              style={{ 
                background: `linear-gradient(45deg, 
                  hsl(${hueRotation}, 100%, 50%), 
                  hsl(${(hueRotation + 120) % 360}, 100%, 50%), 
                  hsl(${(hueRotation + 240) % 360}, 100%, 50%),
                  hsl(${hueRotation}, 100%, 50%)
                )`,
                backgroundSize: '300% 300%',
                animation: 'gradient-shift 2s linear infinite',
                boxShadow: `0 0 15px hsl(${hueRotation}, 100%, 50%)`,
                textShadow: '0 0 5px rgba(0, 0, 0, 0.5)'
              }}
            >
              Play Again
            </button>
          </div>
        </div>
      )}
      
      {/* CSS animations */}
      <style jsx global>{`
        @keyframes pulse {
          0% { transform: scale(0.95); opacity: 0.7; }
          50% { transform: scale(1.05); opacity: 0.9; }
          100% { transform: scale(0.95); opacity: 0.7; }
        }
        
        @keyframes gradient-shift {
          0% { background-position: 0% 50%; }
          100% { background-position: 100% 50%; }
        }
        
        body {
          margin: 0;
          overflow: hidden;
        }
      `}</style>
    </div>
  );
};

export default TripChess;
